<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>鸭子飞了</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="title:leetcode刷题记录75. 颜色分类给定一个包含红色、白色和蓝色，一共 n 个元素的数组，**原地**对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。 此题中，我们使用整数 0、 1 和 2 分别表示红色、白色和蓝色。 12输入：nums &#x3D; [2,0,2,1,1,0]输出：[0,0,1,1,2,2]  思路： 可以先定义两个下标 一个标记0下标 这里是">
<meta property="og:type" content="article">
<meta property="og:title" content="鸭子飞了">
<meta property="og:url" content="https://129duckflew.github.io/2021/03/21/leetcode%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/index.html">
<meta property="og:site_name" content="鸭子飞了">
<meta property="og:description" content="title:leetcode刷题记录75. 颜色分类给定一个包含红色、白色和蓝色，一共 n 个元素的数组，**原地**对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。 此题中，我们使用整数 0、 1 和 2 分别表示红色、白色和蓝色。 12输入：nums &#x3D; [2,0,2,1,1,0]输出：[0,0,1,1,2,2]  思路： 可以先定义两个下标 一个标记0下标 这里是">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://image.duckflew.cn/img/blog_inner_image20201206205914.png">
<meta property="article:published_time" content="2021-03-21T15:31:56.867Z">
<meta property="article:modified_time" content="2021-03-21T15:35:06.472Z">
<meta property="article:author" content="duckflew">
<meta property="article:tag" content="duckflew">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://image.duckflew.cn/img/blog_inner_image20201206205914.png">
  
    <link rel="alternate" href="/atom.xml" title="鸭子飞了" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 5.4.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">鸭子飞了</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">人间凑数的日子里</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://129duckflew.github.io"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-leetcode刷题记录" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/03/21/leetcode%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/" class="article-date">
  <time class="dt-published" datetime="2021-03-21T15:31:56.867Z" itemprop="datePublished">2021-03-21</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <hr>
<h2 id="title-leetcode刷题记录"><a href="#title-leetcode刷题记录" class="headerlink" title=" title:leetcode刷题记录"></a> title:leetcode刷题记录</h2><h3 id="75-颜色分类"><a href="#75-颜色分类" class="headerlink" title="75. 颜色分类"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/sort-colors/">75. 颜色分类</a></h3><p>给定一个包含红色、白色和蓝色，一共 <code>n</code> 个元素的数组，**<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95">原地</a>**对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。</p>
<p>此题中，我们使用整数 <code>0</code>、 <code>1</code> 和 <code>2</code> 分别表示红色、白色和蓝色。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [2,0,2,1,1,0]</span><br><span class="line">输出：[0,0,1,1,2,2]</span><br></pre></td></tr></table></figure>

<p>思路：</p>
<p>可以先定义两个下标 一个标记0下标 这里是zeroIndex  初始化是0 也就是还没出现  </p>
<p>然后从0开始遍历如果遍历到了0那就把 zeroindex对应元素和当前的 遍历的这个0交换一下然后 zero++  那么完成之后 从0到 zeroIndex-1 就都是0 这个数字了  对于1  也 是同理  当然了  在对1进行检测交换的时候   可以直接从下标  zeroIndex开始</p>
<p>代码如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sortColors</span><span class="params">(<span class="keyword">int</span>[] nums)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> zeroLastIndex=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i]==<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            nums[i]=nums[zeroLastIndex];</span><br><span class="line">            nums[zeroLastIndex++]=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> oneLastIndex=zeroLastIndex;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = zeroLastIndex; i &lt; nums.length; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i]==<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            nums[i]=nums[oneLastIndex];</span><br><span class="line">            nums[oneLastIndex++]=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="347-前-K-个高频元素"><a href="#347-前-K-个高频元素" class="headerlink" title="347. 前 K 个高频元素"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/top-k-frequent-elements/">347. 前 K 个高频元素</a></h3><p>(据说是腾讯的笔试题呢) leetcode的要求是要时间复杂度nlogn以下<br><strong>示例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: nums &#x3D; [1,1,1,2,2,3], k &#x3D; 2</span><br><span class="line">输出: [1,2]</span><br></pre></td></tr></table></figure>

<p>这个题 先建立一个  num与次数 count的映射 hashmap  然后遍历  遍历的途中维护一个最大堆   这里用的优先队列</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PriorityQueue&lt;<span class="keyword">int</span>[]&gt; queue=<span class="keyword">new</span> PriorityQueue&lt;&gt;((o1, o2) -&gt; o1[<span class="number">1</span>]-o2[<span class="number">1</span>]);</span><br></pre></td></tr></table></figure>

<p>int[] 第一个数组代表num 第二个数字代表count  后面是排序 这里就有点绕了  如果是个数组 按照这种排序方式 得到理论是个升序才对 但是这里是个优先队列   也是就peek 位置总是堆里面最小的元素 所以在遍历map 只需要与peek[1]比较即可 大于它的话就替换它就行了 当然了 如果堆都没有弄满题目的要求k  那就不判断直接插入堆就行了</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] topKFrequent(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k) &#123;</span><br><span class="line">       Map&lt;Integer,Integer&gt; map=<span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++)</span><br><span class="line">       &#123;</span><br><span class="line">          Integer count=map.get(nums[i]);</span><br><span class="line">          <span class="keyword">if</span> (count==<span class="keyword">null</span>)map.put(nums[i],<span class="number">1</span>);</span><br><span class="line">          <span class="keyword">else</span> map.put(nums[i],count+<span class="number">1</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       PriorityQueue&lt;<span class="keyword">int</span>[]&gt; queue=<span class="keyword">new</span> PriorityQueue&lt;&gt;((o1, o2) -&gt; o1[<span class="number">1</span>]-o2[<span class="number">1</span>]);</span><br><span class="line">       Set&lt;Map.Entry&lt;Integer, Integer&gt;&gt; entries = map.entrySet();</span><br><span class="line">       <span class="keyword">for</span> (Map.Entry&lt;Integer, Integer&gt; entry : entries)</span><br><span class="line">       &#123;</span><br><span class="line">           Integer num = entry.getKey();</span><br><span class="line">           Integer count = entry.getValue();</span><br><span class="line">           <span class="keyword">if</span> (queue.size()==k)</span><br><span class="line">           &#123;</span><br><span class="line">               <span class="keyword">if</span> (count&gt;queue.peek()[<span class="number">1</span>])</span><br><span class="line">               &#123;</span><br><span class="line">                   queue.poll();</span><br><span class="line">                   queue.add(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;num,count&#125;);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">else</span></span><br><span class="line">           &#123;</span><br><span class="line">               queue.add(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;num, count&#125;);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[k];</span><br><span class="line">       <span class="keyword">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">       <span class="keyword">while</span> (queue.size()&gt;<span class="number">0</span>)</span><br><span class="line">       &#123;</span><br><span class="line">           res[cnt++]=queue.poll()[<span class="number">0</span>];</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> res;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>



<h3 id="290-单词规律"><a href="#290-单词规律" class="headerlink" title="290. 单词规律"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/word-pattern/">290. 单词规律</a></h3><blockquote>
<p>给定一种规律 <code>pattern</code> 和一个字符串 <code>str</code> ，判断 <code>str</code> 是否遵循相同的规律。这里的 <strong>遵循</strong> 指完全匹配，例如， <code>pattern</code> 里的每个字母和字符串 <code>str</code> 中的每个非空单词之间存在着双向连接的对应规律。</p>
</blockquote>
<p><strong>示例1:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: pattern &#x3D; &quot;abba&quot;, str &#x3D; &quot;dog cat cat dog&quot;</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure>

<p>先分割str 得到数组 然后比较数组的长度和pattern是不是相等 然后开始遍历 i-&gt;len  如果第一次遇到pattern中的字符  那么就应该为它建立映射  映射到 str数组里面了 但是要先检查 就是str[i]这个字符串是否已经被别的映射了  这种情况也不行的  如果也没有被映射  就可以建立了  如果 不是第一次遇到pattern中的字符那就检查  映射的字符串和str[i]是不是相等的即可</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">wordPattern</span><span class="params">(String pattern, String s)</span> </span>&#123;</span><br><span class="line">        String[] strings = s.split(<span class="string">&quot; &quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (pattern.length()!=strings.length)<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        Map&lt;Character,String&gt; map=<span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pattern.length(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">char</span> ch = pattern.charAt(i);</span><br><span class="line">            String firstValue=map.get(ch);</span><br><span class="line">            <span class="keyword">if</span> (firstValue!=<span class="keyword">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (!strings[i].equals(map.get(ch)))<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (map.containsValue(strings[i]))<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">else</span> map.put(ch,strings[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h3 id="36-有效的数独"><a href="#36-有效的数独" class="headerlink" title="36. 有效的数独"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/valid-sudoku/">36. 有效的数独</a></h3><p>判断一个 9x9 的数独是否有效。只需要根据以下规则，验证已经填入的数字是否有效即可。</p>
<ul>
<li>数字 1-9 在每一行只能出现一次。</li>
<li>数字 1-9 在每一列只能出现一次。</li>
<li>数字 1-9 在每一个以粗实线分隔的 3x3 宫内只能出现一次。</li>
</ul>
<p><img src="https://image.duckflew.cn/img/blog_inner_image20201206205914.png" alt="250px-Sudoku-by-L2G-20050714.svg"></p>
<p>这个题中 有三种情况 行 列 和小数独块  分别为他们设置三个哈希表数组</p>
<p>行  : rowMap=hashMap[9]</p>
<p>列 : colMap=hashMap[9]</p>
<p>子图: sonGraphMap=hashMap[9]</p>
<p>然后对图进行遍历 遍历的过程中 对于点 i j 直接把他映射到对应的map中去  rowMap[i].put colMap[j].put  当然了如果已经存在这个字符了 那就直接返回false了</p>
<p>这里计算子图hashmap数组的下标  是用的如下表达式</p>
<p>sonGraphIndex=i/3*3+j/3</p>
<p>sonGraphMap[sonGraphIndex].put 就行了    这样做时间短一点  但是用了很多空间</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValidSudoku</span><span class="params">(<span class="keyword">char</span>[][]board)</span></span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">       HashMap&lt;Character,Integer&gt; [] rowMap=<span class="keyword">new</span> HashMap[<span class="number">9</span>];</span><br><span class="line">       HashMap&lt;Character,Integer&gt; [] colMap=<span class="keyword">new</span> HashMap[<span class="number">9</span>];</span><br><span class="line">       HashMap&lt;Character,Integer&gt; [] sonGraphMap=<span class="keyword">new</span> HashMap[<span class="number">9</span>];</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span>; i++) &#123;</span><br><span class="line">           rowMap[i] = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">           colMap[i] = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">           sonGraphMap[i] = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span>; i++)</span><br><span class="line">       &#123;</span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">9</span>; j++)</span><br><span class="line">           &#123;</span><br><span class="line">               <span class="keyword">char</span> cur=board[i][j];</span><br><span class="line">               <span class="keyword">if</span> (cur!=<span class="string">&#x27;.&#x27;</span>)</span><br><span class="line">               &#123;</span><br><span class="line">                   <span class="keyword">if</span> (rowMap[i].get(cur)!=<span class="keyword">null</span>)<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                   rowMap[i].put(cur,<span class="number">1</span>);</span><br><span class="line">                   <span class="keyword">if</span> (colMap[j].get(cur)!=<span class="keyword">null</span>)<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                   colMap[j].put(cur,<span class="number">1</span>);</span><br><span class="line">                   <span class="keyword">int</span> sonGraphMapIndex=(i/<span class="number">3</span>)*<span class="number">3</span>+j/<span class="number">3</span>;</span><br><span class="line">                   <span class="keyword">if</span> (sonGraphMap[sonGraphMapIndex].get(cur)!=<span class="keyword">null</span>)<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                   sonGraphMap[sonGraphMapIndex].put(cur,<span class="number">1</span>);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>



<h3 id="3-无重复字符的最长子串"><a href="#3-无重复字符的最长子串" class="headerlink" title="3. 无重复字符的最长子串"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/">3. 无重复字符的最长子串</a></h3><p>给定一个字符串，请你找出其中不含有重复字符的 <strong>最长子串</strong> 的长度。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: s = &quot;abcabcbb&quot;</span><br><span class="line">输出: 3 </span><br><span class="line">解释: 因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度为 3。</span><br></pre></td></tr></table></figure>

<p>思路：用一个hashmap把每个字母一次出现的位置记录下来并且维护一个curheadIndex指针  用来计算当前的子串的长度 当前的i-curheadIndex+1就是当前子串的长度 每一次计算之后都更新一下maxLength变量</p>
<p>在遍历的时候 如果当前的 字符已经出现过 说明curHeadIndex只能从这个字符出现过的位置的下一个位置 当然并不是在这个时候就直接把curHeadIndex赋值为 <code>map.get(ch) + 1</code>还是要首先判断一下这个位置是不是比我当前的curhead的位置大  curheadindex不能后退  例如 给出输入”abba” 如果不判断的话 curheadIndex的变化如下</p>
<p>a 第一次出现  curheadindex不变 还是0</p>
<p>b 第一次出现 curheadindex不变 还是0 </p>
<p>b 第二次出现 curheadindex修改为 2</p>
<p>a 第二次出现 curheadindex 修改为1</p>
<p>最后一次修改就不对了  因为此时 i=3  对应的子串是bba不符合条件   所以在保持curHeadIndex不后退的情况下一直保持下去那子串就是没有重复字符的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s==<span class="keyword">null</span>||s.length() == <span class="number">0</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    Map&lt;Character,Integer&gt;map=<span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">int</span> maxLength=Integer.MIN_VALUE;</span><br><span class="line">    <span class="keyword">int</span> curHeadIndex=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        Character ch=s.charAt(i);</span><br><span class="line">        <span class="keyword">if</span> (map.get(ch) != <span class="keyword">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (map.get(ch)+<span class="number">1</span>&gt;curHeadIndex)</span><br><span class="line">                curHeadIndex = map.get(ch) + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        map.put(ch,i);</span><br><span class="line">        maxLength=Math.max(maxLength,i-curHeadIndex+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxLength;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="503-下一个更大元素"><a href="#503-下一个更大元素" class="headerlink" title="503. 下一个更大元素||"></a>503. 下一个更大元素||</h3><p>在496题的基础 把数改成了循环数组  要求输出每一个元素对应的右侧的最大近更大的元素<br> 几乎是一样的做法  但是需要循环两遍 而且第二遍不需要push i 了因为第一遍 如果i 能够如栈就已经入栈了  第二遍只是检查在循环的情况下 如果栈里面有剩余元素  看能否再次找到一些有下一个更大元素的  相当于栈内的元素 在第二次遍历前还是有机会找到自己的下一个更大元素 的 原因就是这是一个循环数组<br>6 3  4 5 5  第一次遍历  栈里面肯定还剩余  6 5 5 (应该是写下标的 这里为了表达的清楚就直接写了元素) 然后第二次遍历  5 5 就可以出栈进行记录 了6最后剩余在栈里面因此得到的 res=[-1, 4, 5, 6, 6]<br>代码如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span>  <span class="keyword">int</span>[] nextGreaterElements(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        Stack&lt;Integer&gt; stack=<span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span>[] res=<span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">             <span class="keyword">while</span> (!stack.isEmpty()&amp;&amp;nums[i]&gt;nums[stack.lastElement()])</span><br><span class="line">             &#123;</span><br><span class="line">                 <span class="keyword">int</span> topIndex=stack.pop();</span><br><span class="line">                 res[topIndex]=nums[i];</span><br><span class="line">             &#125;</span><br><span class="line">             stack.push(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (stack.isEmpty())<span class="keyword">return</span> res;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span> (!stack.isEmpty()&amp;&amp;nums[i]&gt;nums[stack.lastElement()])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> topIndex=stack.pop();</span><br><span class="line">                res[topIndex]=nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty())</span><br><span class="line">        &#123;</span><br><span class="line">            res[stack.pop()]=-<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="496-下一个更大元素"><a href="#496-下一个更大元素" class="headerlink" title="496.下一个更大元素"></a>496.下一个更大元素</h3><blockquote>
<p>给定两个 没有重复元素 的数组 nums1 和 nums2 ，其中nums1 是 nums2 的子集。找到 nums1 中每个元素在 nums2 中的下一个比其大的值。<br>nums1 中数字 x 的下一个更大元素是指 x 在 nums2 中对应位置的右边的第一个比 x 大的元素。如果不存在，对应位置输出 -1 </p>
</blockquote>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: nums1 = [4,1,2], nums2 = [1,3,4,2].</span><br><span class="line">输出: [-1,3,-1]</span><br></pre></td></tr></table></figure>
<p>这是个单调栈的问题 跟下面的每日温度属于同一个类型的题  既然nums1是nums2的子集然后找到右侧的第一个比当前元素大的元素 那只需要设置一个栈 然后遍历nums2 维持这个栈为一个从栈底到栈顶递减的栈 例如上面的例子过程如下<br>首先因为是空 1 入栈 然后3 比1 大  1出栈  这里就表示1右边的第一个比他大的元素就是3 用一个hashmap的键值对存储起来  1-&gt;3 ，然后3 入栈  接下来是4 4比3大  3出栈  map放入3-&gt;4 然后4入栈 下面是 2  直接入栈<br>那对于 4 1 2 得到的res数组就是  -1 3 2  因为4,和1  还在栈里面并没有存储到map 那map如果get不到这个值 就直接让对应的res[i]=-1就行了  下面是代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] nextGreaterElement(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span>[] nums2) &#123;</span><br><span class="line">        <span class="keyword">int</span> res[]=<span class="keyword">new</span> <span class="keyword">int</span>[nums1.length];</span><br><span class="line">        Stack&lt;Integer&gt; stack=<span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        Map&lt;Integer,Integer&gt; firstNumBigThanNum=<span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums2.length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> cur=nums2[i];</span><br><span class="line">            <span class="keyword">while</span> (!stack.isEmpty()&amp;&amp;stack.lastElement()&lt;cur)</span><br><span class="line">            &#123;</span><br><span class="line">                firstNumBigThanNum.put(stack.pop(),cur);</span><br><span class="line">            &#125;</span><br><span class="line">            stack.push(cur);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums1.length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            Integer get = firstNumBigThanNum.get(nums1[i]);</span><br><span class="line">            res[i]=get!=<span class="keyword">null</span>?get:-<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="522-设计循环队列"><a href="#522-设计循环队列" class="headerlink" title="522.设计循环队列"></a>522.设计循环队列</h3><p>利用数组实现 设置两个值 head 和tail 每一个时刻<br><code>tail=(head+size)%capacity</code><br>size表示队列的元素个数  capacity表示队列的最大容量 在返回rear队尾元素时候 返回的是tail的前一个元素</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> index=tail-<span class="number">1</span>&lt;<span class="number">0</span>?(tail-<span class="number">1</span>+capacity):tail-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> queue[index];</span><br></pre></td></tr></table></figure>
<p>下面是全部代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyCircularQueue</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] queue;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> capacity;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> head;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> tail;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyCircularQueue</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        queue=<span class="keyword">new</span> <span class="keyword">int</span>[k];</span><br><span class="line">        size=<span class="number">0</span>;</span><br><span class="line">        head=<span class="number">0</span>;</span><br><span class="line">        tail=<span class="number">0</span>;</span><br><span class="line">        capacity=k;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">enQueue</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (size==capacity)<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        queue[tail]=value;</span><br><span class="line">        size++;</span><br><span class="line">        tail=(head+size)%capacity;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">deQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (size==<span class="number">0</span>)<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        size--;</span><br><span class="line">        head=(head+<span class="number">1</span>)%capacity;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">Front</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (size==<span class="number">0</span>)<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> queue[head];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">Rear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (size==<span class="number">0</span>)<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> index=tail-<span class="number">1</span>&lt;<span class="number">0</span>?(tail-<span class="number">1</span>+capacity):tail-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> queue[index];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> size==<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isFull</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> size==capacity;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//    public void show()</span></span><br><span class="line"><span class="comment">//    &#123;</span></span><br><span class="line"><span class="comment">//        if (size==0)System.out.println(&quot;null&quot;);</span></span><br><span class="line"><span class="comment">//        else</span></span><br><span class="line"><span class="comment">//        &#123;</span></span><br><span class="line"><span class="comment">//            System.out.println(&quot;head=&quot;+head+&quot;    tail=&quot;+tail+&quot;   size=&quot;+size) ;</span></span><br><span class="line"><span class="comment">//            do</span></span><br><span class="line"><span class="comment">//            &#123;</span></span><br><span class="line"><span class="comment">//                if (head &gt;= capacity) head = head % capacity;</span></span><br><span class="line"><span class="comment">//                System.out.print(queue[head++] + &quot; &quot;);</span></span><br><span class="line"><span class="comment">//            &#125; while (head != tail);</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="232-用两个栈来实现队列"><a href="#232-用两个栈来实现队列" class="headerlink" title="232.用两个栈来实现队列"></a>232.用两个栈来实现队列</h3><p>一个栈inStack 一个outStack  一个顺序的队列进栈出栈再进栈 顺序不变<br>push的时候 如果out里面没有元素了 那就把in里面所有的元素送到out 否则的直接push到In即可<br>pop的时候要看out是否为空 如果为空  就要把in的所有元素都添加过来 然后在Pop<br>总之就是以out优先  因为out里面的顺序才是元素添加进来的真实顺序才满足队列的要求</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyQueue</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Stack&lt;Integer&gt; inStack;</span><br><span class="line">    <span class="keyword">private</span> Stack&lt;Integer&gt; outStack;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        inStack=<span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        outStack=<span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (outStack.isEmpty())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span> (!inStack.isEmpty())</span><br><span class="line">            &#123;</span><br><span class="line">                outStack.push(inStack.pop());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        inStack.push(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (outStack.isEmpty())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span> (!inStack.isEmpty())</span><br><span class="line">            &#123;</span><br><span class="line">                outStack.push(inStack.pop());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> outStack.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (outStack.isEmpty())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span> (!inStack.isEmpty())</span><br><span class="line">            &#123;</span><br><span class="line">                outStack.push(inStack.pop());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> outStack.lastElement();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> inStack.isEmpty()&amp;&amp;outStack.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="225-用两个队列实现栈"><a href="#225-用两个队列实现栈" class="headerlink" title="225.用两个队列实现栈"></a>225.用两个队列实现栈</h3><p>思路 一个主队列 一个副队列<br>当有元素要push进来的时候 直接加入在主队列后面<br>如果要pop的时候先让主队列依次poll到副队列  然后让队列尾部的元素poll 再把副队列的的元素挪回来  相当于前面的人暂时消失 队尾的人打到饭走了  然后前面的人回来了<br>peek也是同理  empty的话  两个队列都是空就返回empty就行了</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">while</span> (mainQueue.size()&gt;<span class="number">1</span>)</span><br><span class="line">      &#123;</span><br><span class="line">          viceQueue.add(mainQueue.poll());</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">int</span> popRes=mainQueue.poll();</span><br><span class="line">      <span class="keyword">while</span> (!viceQueue.isEmpty())</span><br><span class="line">      &#123;</span><br><span class="line">          mainQueue.add(viceQueue.poll());</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> popRes;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h3 id="155-最小栈"><a href="#155-最小栈" class="headerlink" title="155 最小栈"></a>155 最小栈</h3><blockquote>
<p>设计一个支持 push ，pop ，top 操作，并能在常数时间内检索到最小元素的栈。</p>
</blockquote>
<p>思路就是 除了基本的数据栈 还增加一个 辅助栈  minDataStack<br><code>push</code>的话就是   如果需要push的话  当然是先入数据栈 然后判断<br> 小于等于辅助栈 栈顶元素  那就入栈  为什么是小于等于呢  考虑如下的情况  假设不是小于等于而是小于的情况下 push 100 87 87  那我的辅助栈就处于现在的情况了100 87 然后假设我Pop87   现在  数据栈还剩余100 和87  但是辅助栈剩余 100  显示的当前的最小值就是100  当然是不行的<br><code>pop</code>的话  就是pop当前的元素 并且和辅助栈栈顶部的元素比较 如果等于栈顶的元素 说明这就是一个最小值 需要把<code>minDataStack</code>也<code>pop</code>掉  其他的没什么好说的 要获取当前的最小值的话就是<code>return minDataStack.lastElement</code>就行了</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        s.push(x);</span><br><span class="line">        <span class="keyword">if</span> (minData.isEmpty()||x&lt;=minData.lastElement())minData.push(x);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (minData.lastElement().equals(s.pop()))minData.pop();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="739-每日温度"><a href="#739-每日温度" class="headerlink" title="739.每日温度"></a>739.每日温度</h3><blockquote>
<p>请根据每日 气温 列表，重新生成一个列表。对应位置的输出为：要想观测到更高的气温，至少需要等待的天数。如果气温在这之后都不会升高，请在该位置用 0 来代替。<br>例如，给定一个列表 temperatures = [73, 74, 75, 71, 69, 72, 76, 73]，你的输出应该是 [1, 1, 4, 2, 1, 1, 0, 0]</p>
</blockquote>
<p>这个题首先遍历T数组<br>设置一个栈  来存储每个温度对应的下标索引值 并且这些索引对应的温度体现在这个栈内部应该是一个温度递减的栈 为什么要温度递减？ 因为我们要求的是接下来的多少天能够使得温度升高  那就只要把中间一直在递减的温度的索引一直存进去 知道遇到某个索引时 他对应的温度不满足递减了  那就用这个索引减去栈内部的索引得到的差值就是需要的天数  注意点 如果当前的温度一直比栈顶对应的温度高 那就要一直pop并且把对应的天数存储到结果数组里面去  举例如下<br>[73, 74, 75, 71, 69, 72, 76, 73] 这个温度序列   遍历它<br>t=73  stack empty 0入栈<br>t=74  比栈顶0对应的温度高  那就把0出栈 res[0]=1(74的索引)-0=1;<br>然后把 74的索引入栈 1  因为栈已经空了  否则还要继续比下去<br>t=75  同样的  74对应的1 出栈  75的2进栈 res[1]=1;<br>然后就是 71 69 他们是递减的  直接入栈即可<br>然后就是   72  那 71 69就要出栈  并且在res的的对应位置上赋值 值就是72的索引减去他们各自的索引  然后72 入栈  此时栈内还剩 2对应温度75,5(对应温度72）  然后继续进行下去就可以了<br><strong>最后还需要判断一下</strong>  栈里面还没有元素  还有的话依次把他们出栈 并且他们的对应的res的值为0 表示的就是自这个温度以后找不到更高的温度了 那就只能是0</p>
<h3 id="240-搜索二维矩阵"><a href="#240-搜索二维矩阵" class="headerlink" title="240.搜索二维矩阵"></a>240.搜索二维矩阵</h3><p>在一个有规律的矩阵中搜索特定的值<br>这个矩阵的规律如下</p>
<ul>
<li>每行的元素从左到右升序排列。</li>
<li>每列的元素从上到下升序排列。</li>
</ul>
<p><strong>解法1</strong></p>
<p>逐行遍历 二分搜索  每次遍历先判断一下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (matrix[i][<span class="number">0</span>]&gt;target)<span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">if</span> (matrix[i][matrix[i].length-<span class="number">1</span>]&lt;target)<span class="keyword">continue</span>;</span><br></pre></td></tr></table></figure>

<p>如果本行的第一个元素大于target 这一行就不用看了</p>
<p>如果本行的最后一个元素小于target 这一行也不用看了</p>
<p> 算是个小的优化</p>
<p><strong>解法2</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">数组从左到右和从上到下都是升序的，如果从右上角出发开始遍历呢？</span><br><span class="line"></span><br><span class="line">会发现每次都是向左数字会变小，向下数字会变大，有点和二分查找树相似。二分查找树的话，是向左数字变小，向右数字变大。</span><br><span class="line"></span><br><span class="line">所以我们可以把 target 和当前值比较。</span><br><span class="line"></span><br><span class="line">如果 target 的值大于当前值，那么就向下走。</span><br><span class="line">如果 target 的值小于当前值，那么就向左走。</span><br><span class="line">如果相等的话，直接返回 <span class="keyword">true</span> 。</span><br><span class="line">也可以换个角度思考。</span><br><span class="line"></span><br><span class="line">如果 target 的值小于当前值，也就意味着当前值所在的列肯定不会存在 target 了，可以把当前列去掉，从新的右上角的值开始遍历。</span><br><span class="line"></span><br><span class="line">同理，如果 target 的值大于当前值，也就意味着当前值所在的行肯定不会存在 target 了，可以把当前行去掉，从新的右上角的值开始遍历。</span><br><span class="line"></span><br><span class="line">看下边的例子。</span><br><span class="line">[<span class="number">2</span>,   <span class="number">5</span>,  <span class="number">8</span>, <span class="number">12</span>, <span class="number">19</span>],</span><br><span class="line">[<span class="number">3</span>,   <span class="number">6</span>,  <span class="number">9</span>, <span class="number">16</span>, <span class="number">22</span>],</span><br><span class="line">[<span class="number">10</span>, <span class="number">13</span>, <span class="number">14</span>, <span class="number">17</span>, <span class="number">24</span>],</span><br><span class="line">[<span class="number">18</span>, <span class="number">21</span>, <span class="number">23</span>, <span class="number">26</span>, <span class="number">30</span>]</span><br><span class="line"></span><br><span class="line">如果 target  = <span class="number">9</span>，如果我们从 <span class="number">15</span> 开始遍历, cur = <span class="number">15</span></span><br><span class="line">    </span><br><span class="line">target &lt; <span class="number">15</span>, 去掉当前列, cur = <span class="number">11</span></span><br><span class="line">[<span class="number">1</span>,   <span class="number">4</span>,  <span class="number">7</span>, <span class="number">11</span>],</span><br><span class="line">[<span class="number">2</span>,   <span class="number">5</span>,  <span class="number">8</span>, <span class="number">12</span>],</span><br><span class="line">[<span class="number">3</span>,   <span class="number">6</span>,  <span class="number">9</span>, <span class="number">16</span>],</span><br><span class="line">[<span class="number">10</span>, <span class="number">13</span>, <span class="number">14</span>, <span class="number">17</span>],</span><br><span class="line">[<span class="number">18</span>, <span class="number">21</span>, <span class="number">23</span>, <span class="number">26</span>]    </span><br><span class="line">    </span><br><span class="line">target &lt; <span class="number">11</span>, 去掉当前列, cur = <span class="number">7</span>  </span><br><span class="line">[<span class="number">1</span>,   <span class="number">4</span>,  <span class="number">7</span>],</span><br><span class="line">[<span class="number">2</span>,   <span class="number">5</span>,  <span class="number">8</span>],</span><br><span class="line">[<span class="number">3</span>,   <span class="number">6</span>,  <span class="number">9</span>],</span><br><span class="line">[<span class="number">10</span>, <span class="number">13</span>, <span class="number">14</span>],</span><br><span class="line">[<span class="number">18</span>, <span class="number">21</span>, <span class="number">23</span>]     </span><br><span class="line"></span><br><span class="line">target &gt; <span class="number">7</span>, 去掉当前行, cur = <span class="number">8</span>   </span><br><span class="line">[<span class="number">2</span>,   <span class="number">5</span>,  <span class="number">8</span>],</span><br><span class="line">[<span class="number">3</span>,   <span class="number">6</span>,  <span class="number">9</span>],</span><br><span class="line">[<span class="number">10</span>, <span class="number">13</span>, <span class="number">14</span>],</span><br><span class="line">[<span class="number">18</span>, <span class="number">21</span>, <span class="number">23</span>]       </span><br><span class="line"></span><br><span class="line">target &gt; <span class="number">8</span>, 去掉当前行, cur = <span class="number">9</span>, 遍历结束    </span><br><span class="line">[<span class="number">3</span>,   <span class="number">6</span>,  <span class="number">9</span>],</span><br><span class="line">[<span class="number">10</span>, <span class="number">13</span>, <span class="number">14</span>],</span><br><span class="line">[<span class="number">18</span>, <span class="number">21</span>, <span class="number">23</span>]   </span><br></pre></td></tr></table></figure>

<p>代码如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">if</span> (matrix==<span class="keyword">null</span>||matrix.length==<span class="number">0</span>||matrix[<span class="number">0</span>].length==<span class="number">0</span>)<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">int</span> curCol=matrix[<span class="number">0</span>].length-<span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> curRow=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> cur;</span><br><span class="line"><span class="keyword">while</span> (curCol&gt;=<span class="number">0</span>&amp;&amp;curRow&lt;matrix.length)</span><br><span class="line">&#123;</span><br><span class="line">    cur=matrix[curRow][curCol];</span><br><span class="line">    <span class="keyword">if</span> (cur==target)<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (cur&gt;target) curCol--;</span><br><span class="line">    <span class="keyword">else</span> curRow++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br></pre></td></tr></table></figure>


<h3 id="283-移动0"><a href="#283-移动0" class="headerlink" title="283. 移动0"></a>283. 移动0</h3><blockquote>
<p>给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [0,1,0,3,12]</span><br><span class="line">输出: [1,3,12,0,0]</span><br></pre></td></tr></table></figure>

<p><strong>思路</strong>:可以把这个数组当成一条路，两个指针（i,j），相当于两个人，其中i具有飞行能力，j没有，这条路0相当于一条河（i可以飞过去，j不行），所以当碰到河（0）时，i飞过去了，j就停在河边，当i碰到非0（陆地）时，他会将这个陆地（非0）复制到j的前面让j前进。<br>这样一个过程下来，i会将这条路（数组）走完，j会停留在河流（0）或者重复陆地（非0）边。此时j的后面就是重复的数字或者0了，直接for赋值为0即可</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">moveZeroes</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">if</span> (nums==<span class="keyword">null</span>||nums.length==<span class="number">0</span>)<span class="keyword">return</span> ;</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> j=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (;i&lt;nums.length;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i]!=<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                nums[j++]=nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (;j&lt;nums.length;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            nums[j]=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="566-重塑矩阵"><a href="#566-重塑矩阵" class="headerlink" title="566.重塑矩阵"></a>566.重塑矩阵</h3><p>先判断 重塑前的总元素个数是否等于需要重塑后的尺寸 相等的话 遍历二维数组依次填充即可<br>填充方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[][] newNums = <span class="keyword">new</span> <span class="keyword">int</span>[r][c];</span><br><span class="line">        <span class="keyword">int</span> newRow=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> newCol=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;nums[i].length;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                newNums[newRow][newCol++]=nums[i][j];</span><br><span class="line">                <span class="keyword">if</span> (newCol==c)</span><br><span class="line">                &#123;</span><br><span class="line">                    newCol=<span class="number">0</span>;</span><br><span class="line">                    newRow++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="keyword">return</span>  newNums;</span><br></pre></td></tr></table></figure>

<h3 id="697-数组的度"><a href="#697-数组的度" class="headerlink" title="697.数组的度"></a>697.数组的度</h3><blockquote>
<p>题目:  给定一个非空且只包含非负数的整数数组 nums, 数组的度的定义是指数组里任一元素出现频数的最大值。<br>你的任务是找到与 nums 拥有相同大小的度的最短连续子数组，返回其长度。</p>
</blockquote>
<blockquote>
<p>思路:具有度数 d 的数组必须有一些元素 x 出现 d 次。如果某些子数组具有相同的度数，那么某些元素 x （出现 d 次）。最短的子数组是将从 x 的第一次出现到最后一次出现的数组。<br>对于给定数组中的每个元素，让我们知道 left 是它第一次出现的索引； right 是它最后一次出现的索引。例如，当 nums = [1,2,3,2,5] 时，left[2] = 1 和 right[2] = 3。<br>然后，对于出现次数最多的每个元素 x，right[x] - left[x] + 1 将是我们的候选答案，我们将取这些候选的最小值。</p>
</blockquote>
<p>一个map left放第一次出现的位置 一个right 放最后一次出现的位置 一个counts放每个数字出现的次数<br>遍历数组 right存入当前的数字以及位置  因为存储的最后的位置 只需要不断覆盖就行   然后判断left.get(当前数字)是不是为空 是的话存入当前位置并且设置count=1 后面每次不为空的时候就更新count 更新方法就是先取出然后覆盖 官方有一个小技巧写法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">counts.put(cur,counts.getOrDefault(cur,<span class="number">0</span>)+<span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<p>代码:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;Integer,Integer&gt; left=<span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">       Map&lt;Integer,Integer&gt;  right=<span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">       Map&lt;Integer,Integer&gt;  counts=<span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)</span><br><span class="line">       &#123;</span><br><span class="line">           <span class="keyword">int</span> cur=nums[i];</span><br><span class="line">           right.put(cur,i);</span><br><span class="line">           <span class="keyword">if</span> (left.get(cur)!=<span class="keyword">null</span>)</span><br><span class="line">           &#123;</span><br><span class="line">               Integer count = counts.get(cur);</span><br><span class="line">               counts.put(cur,count+<span class="number">1</span>);</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">else</span></span><br><span class="line">           &#123;</span><br><span class="line">               left.put(cur,i);</span><br><span class="line">               counts.put(cur,<span class="number">1</span>);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       Integer maxCount = Collections.max(counts.values());</span><br><span class="line">       <span class="keyword">int</span> res=nums.length;</span><br><span class="line">       <span class="keyword">for</span> (Integer key:counts.keySet())</span><br><span class="line">       &#123;</span><br><span class="line">           <span class="keyword">if</span> (counts.get(key).equals(maxCount))</span><br><span class="line">           &#123;</span><br><span class="line">               res=Math.min(res,right.get(key)-left.get(key)+<span class="number">1</span>);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> res;</span><br></pre></td></tr></table></figure>

<h3 id="1365-求数组中有多少小于当前数字的数字"><a href="#1365-求数组中有多少小于当前数字的数字" class="headerlink" title="1365.求数组中有多少小于当前数字的数字"></a>1365.求数组中有多少小于当前数字的数字</h3><p>思路 用一个哈希表来存储<br><code>Map&lt;Integer,HashSet()&gt;indexOfValues</code><br>复制一份原数组  进行排序  排序完成后 对于每一个元素我的索引是多少 就有多少数字比我小 我只需要把每个数字对应的排序后的索引存储到indexOfValues的对应的key的hashset中   然后遍历原数组  对于每一个元素  找到这个元素对应的装索引的HashSet  取最小的值  就是小于这个数字的数字的个数<br>代码如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> len=nums.length;</span><br><span class="line">       Map&lt;Integer, HashSet&lt;Integer&gt;&gt;indexOfValues=<span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">       <span class="keyword">int</span>[] newNums = Arrays.copyOf(nums, len);</span><br><span class="line">       Arrays.sort(newNums);</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;newNums.length;i++)</span><br><span class="line">       &#123;</span><br><span class="line">           <span class="keyword">int</span> cur=newNums[i];</span><br><span class="line">           HashSet&lt;Integer&gt; indexSet = indexOfValues.getOrDefault(cur,<span class="keyword">new</span> HashSet&lt;&gt;());</span><br><span class="line">           indexSet.add(i);</span><br><span class="line">           indexOfValues.put(cur,indexSet);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">int</span>[] res=<span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)</span><br><span class="line">       &#123;</span><br><span class="line">           <span class="keyword">int</span> cur=nums[i];</span><br><span class="line">           Integer min = Collections.min(indexOfValues.get(cur));</span><br><span class="line">           res[i]=min;</span><br><span class="line">       &#125;</span><br><span class="line"> <span class="keyword">return</span> res;</span><br></pre></td></tr></table></figure>

<h3 id="766-托普利茨矩阵"><a href="#766-托普利茨矩阵" class="headerlink" title="766.托普利茨矩阵"></a>766.托普利茨矩阵</h3><blockquote>
<p>如果矩阵上每一条由左上到右下的对角线上的元素都相同，那么这个矩阵是 托普利茨矩阵 。<br>例如<br>[1,2,3,4],<br>[5,1,2,3],<br>[9,5,1,2]<br>给定一个 M x N 的矩阵，当且仅当它是托普利茨矩阵时返回 True。</p>
</blockquote>
<p>思路:同一条对角线 有一个直线表达式  例如最长的对角线就满足j-i=0;<br>我们将j-i所有可以取到的值放入map 并且从第一排和第一列取一个验证值放进去作为value 然后遍历整个矩阵  如果i行j列的元素不等于map.get(j-i)中取出来的value验证值 说明不是托普利茨矩阵</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;Integer,Integer&gt; dataOfEveryLine=<span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;matrix[<span class="number">0</span>].length;j++)</span><br><span class="line">       &#123;</span><br><span class="line">           dataOfEveryLine.put(j-<span class="number">0</span>,matrix[<span class="number">0</span>][j]);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;matrix.length;i++)</span><br><span class="line">       &#123;</span><br><span class="line">           dataOfEveryLine.put(<span class="number">0</span>-i,matrix[i][<span class="number">0</span>]);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; matrix.length; i++)</span><br><span class="line">       &#123;</span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; matrix[i].length; j++)</span><br><span class="line">           &#123;</span><br><span class="line">               <span class="keyword">if</span> (matrix[i][j]!=dataOfEveryLine.get(j-i))<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">true</span>;</span><br></pre></td></tr></table></figure>

<h3 id="645-错误的集合"><a href="#645-错误的集合" class="headerlink" title="645.错误的集合"></a>645.错误的集合</h3><blockquote>
<p>集合 S 包含从1到 n 的整数。不幸的是，因为数据错误，导致集合里面某一个元素复制了成了集合里面的另外一个元素的值，导致集合丢失了一个整数并且有一个元素重复。</p>
</blockquote>
<p>给定一个数组 nums 代表了集合 S 发生错误后的结果。你的任务是首先寻找到重复出现的整数，再找到丢失的整数，将它们以数组的形式返回。<br>示例 1:<br>输入: nums = [1,2,2,4]<br>输出: [2,3]</p>
<p>思路:<br>第一次遍历数组  对于每个数组元素 这个元素-1一定会对应一个唯一的下表 除了那个重复的元素  所以我们通过这个下标来把第一次访问的元素置为负数 这样遍历下去 如果发现 某一次通过当前的元素值-1得到的下标 已经是个负数了 说明这个值的绝对值对应的就是重复的元素  存储下来即可 不需要进行改变 这个过程中总共 置负了length-1次  有一次是判断到负数了  所以必然有一个值没有被赋值 这个值的下标+1就是缺失的元素了<br>第二次遍历数组 只需要找到是正数的那个元素<br>注意点:在取元素然后-1作为下标的时候其实要取的是元素的绝对值</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> repeatNum = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//System.out.println(Arrays.toString(nums));</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)</span><br><span class="line">        &#123;</span><br><span class="line">           <span class="keyword">int</span> cur=nums[i];</span><br><span class="line">           <span class="keyword">if</span> (nums[Math.abs(cur)-<span class="number">1</span>]&gt;<span class="number">0</span>)nums[Math.abs(cur)-<span class="number">1</span>]*=-<span class="number">1</span>;</span><br><span class="line">           <span class="keyword">else</span></span><br><span class="line">           &#123;</span><br><span class="line">               repeatNum=Math.abs(cur);</span><br><span class="line">           &#125;</span><br><span class="line">         <span class="comment">//System.out.println(Arrays.toString(nums));</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> missing = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i]&gt;<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                missing=i+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;repeatNum,missing&#125;;</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="https://129duckflew.github.io/2021/03/21/leetcode%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/" data-id="ckmjbdb9g000gm4ve3bbsddme" data-title="" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2021/03/21/LeetCode%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95---%E9%93%BE%E8%A1%A8/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          (no title)
        
      </div>
    </a>
  
  
    <a href="/2021/03/21/LeetCode%20%E7%AC%94%E8%AE%B0--%E5%88%86%E6%B2%BB%E6%B3%95/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title"></div>
    </a>
  
</nav>

  
</article>


</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/03/">March 2021</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2021/03/21/%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F/">(no title)</a>
          </li>
        
          <li>
            <a href="/2021/03/21/%E5%87%A0%E4%B8%AA%E5%A5%BD%E7%94%A8%E7%9A%84%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7/">(no title)</a>
          </li>
        
          <li>
            <a href="/2021/03/21/%E5%87%A0%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/">(no title)</a>
          </li>
        
          <li>
            <a href="/2021/03/21/%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91%E7%9A%84%E5%BB%BA%E7%AB%8B%E4%BB%A5%E5%8F%8A%E6%B1%82WPL%20%E4%BB%A5%E5%8F%8A%E5%93%88%E5%A4%AB%E6%9B%BC%E7%BC%96%E7%A0%81/">(no title)</a>
          </li>
        
          <li>
            <a href="/2021/03/21/%E5%B9%BF%E4%B9%89%E8%A1%A8/">(no title)</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2021 duckflew<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>