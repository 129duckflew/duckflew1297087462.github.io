<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>鸭子飞了</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="github个人页面">
<meta property="og:type" content="website">
<meta property="og:title" content="鸭子飞了">
<meta property="og:url" content="https://129duckflew.github.io/page/2/index.html">
<meta property="og:site_name" content="鸭子飞了">
<meta property="og:description" content="github个人页面">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="duckflew">
<meta property="article:tag" content="duckflew">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="鸭子飞了" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 5.4.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">鸭子飞了</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">人间凑数的日子里</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://129duckflew.github.io"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-leetcode刷题记录" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/03/21/leetcode%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/" class="article-date">
  <time class="dt-published" datetime="2021-03-21T15:31:56.867Z" itemprop="datePublished">2021-03-21</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/03/21/leetcode%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/">leetcode刷题记录</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h3 id="75-颜色分类"><a href="#75-颜色分类" class="headerlink" title="75. 颜色分类"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/sort-colors/">75. 颜色分类</a></h3><p>给定一个包含红色、白色和蓝色，一共 <code>n</code> 个元素的数组，**<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95">原地</a>**对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。</p>
<p>此题中，我们使用整数 <code>0</code>、 <code>1</code> 和 <code>2</code> 分别表示红色、白色和蓝色。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [2,0,2,1,1,0]</span><br><span class="line">输出：[0,0,1,1,2,2]</span><br></pre></td></tr></table></figure>

<p>思路：</p>
<p>可以先定义两个下标 一个标记0下标 这里是zeroIndex  初始化是0 也就是还没出现  </p>
<p>然后从0开始遍历如果遍历到了0那就把 zeroindex对应元素和当前的 遍历的这个0交换一下然后 zero++  那么完成之后 从0到 zeroIndex-1 就都是0 这个数字了  对于1  也 是同理  当然了  在对1进行检测交换的时候   可以直接从下标  zeroIndex开始</p>
<p>代码如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sortColors</span><span class="params">(<span class="keyword">int</span>[] nums)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> zeroLastIndex=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i]==<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            nums[i]=nums[zeroLastIndex];</span><br><span class="line">            nums[zeroLastIndex++]=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> oneLastIndex=zeroLastIndex;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = zeroLastIndex; i &lt; nums.length; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i]==<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            nums[i]=nums[oneLastIndex];</span><br><span class="line">            nums[oneLastIndex++]=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="347-前-K-个高频元素"><a href="#347-前-K-个高频元素" class="headerlink" title="347. 前 K 个高频元素"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/top-k-frequent-elements/">347. 前 K 个高频元素</a></h3><p>(据说是腾讯的笔试题呢) leetcode的要求是要时间复杂度nlogn以下<br><strong>示例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: nums &#x3D; [1,1,1,2,2,3], k &#x3D; 2</span><br><span class="line">输出: [1,2]</span><br></pre></td></tr></table></figure>

<p>这个题 先建立一个  num与次数 count的映射 hashmap  然后遍历  遍历的途中维护一个最大堆   这里用的优先队列</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PriorityQueue&lt;<span class="keyword">int</span>[]&gt; queue=<span class="keyword">new</span> PriorityQueue&lt;&gt;((o1, o2) -&gt; o1[<span class="number">1</span>]-o2[<span class="number">1</span>]);</span><br></pre></td></tr></table></figure>

<p>int[] 第一个数组代表num 第二个数字代表count  后面是排序 这里就有点绕了  如果是个数组 按照这种排序方式 得到理论是个升序才对 但是这里是个优先队列   也是就peek 位置总是堆里面最小的元素 所以在遍历map 只需要与peek[1]比较即可 大于它的话就替换它就行了 当然了 如果堆都没有弄满题目的要求k  那就不判断直接插入堆就行了</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] topKFrequent(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k) &#123;</span><br><span class="line">       Map&lt;Integer,Integer&gt; map=<span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++)</span><br><span class="line">       &#123;</span><br><span class="line">          Integer count=map.get(nums[i]);</span><br><span class="line">          <span class="keyword">if</span> (count==<span class="keyword">null</span>)map.put(nums[i],<span class="number">1</span>);</span><br><span class="line">          <span class="keyword">else</span> map.put(nums[i],count+<span class="number">1</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       PriorityQueue&lt;<span class="keyword">int</span>[]&gt; queue=<span class="keyword">new</span> PriorityQueue&lt;&gt;((o1, o2) -&gt; o1[<span class="number">1</span>]-o2[<span class="number">1</span>]);</span><br><span class="line">       Set&lt;Map.Entry&lt;Integer, Integer&gt;&gt; entries = map.entrySet();</span><br><span class="line">       <span class="keyword">for</span> (Map.Entry&lt;Integer, Integer&gt; entry : entries)</span><br><span class="line">       &#123;</span><br><span class="line">           Integer num = entry.getKey();</span><br><span class="line">           Integer count = entry.getValue();</span><br><span class="line">           <span class="keyword">if</span> (queue.size()==k)</span><br><span class="line">           &#123;</span><br><span class="line">               <span class="keyword">if</span> (count&gt;queue.peek()[<span class="number">1</span>])</span><br><span class="line">               &#123;</span><br><span class="line">                   queue.poll();</span><br><span class="line">                   queue.add(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;num,count&#125;);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">else</span></span><br><span class="line">           &#123;</span><br><span class="line">               queue.add(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;num, count&#125;);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[k];</span><br><span class="line">       <span class="keyword">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">       <span class="keyword">while</span> (queue.size()&gt;<span class="number">0</span>)</span><br><span class="line">       &#123;</span><br><span class="line">           res[cnt++]=queue.poll()[<span class="number">0</span>];</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> res;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>



<h3 id="290-单词规律"><a href="#290-单词规律" class="headerlink" title="290. 单词规律"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/word-pattern/">290. 单词规律</a></h3><blockquote>
<p>给定一种规律 <code>pattern</code> 和一个字符串 <code>str</code> ，判断 <code>str</code> 是否遵循相同的规律。这里的 <strong>遵循</strong> 指完全匹配，例如， <code>pattern</code> 里的每个字母和字符串 <code>str</code> 中的每个非空单词之间存在着双向连接的对应规律。</p>
</blockquote>
<p><strong>示例1:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: pattern &#x3D; &quot;abba&quot;, str &#x3D; &quot;dog cat cat dog&quot;</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure>

<p>先分割str 得到数组 然后比较数组的长度和pattern是不是相等 然后开始遍历 i-&gt;len  如果第一次遇到pattern中的字符  那么就应该为它建立映射  映射到 str数组里面了 但是要先检查 就是str[i]这个字符串是否已经被别的映射了  这种情况也不行的  如果也没有被映射  就可以建立了  如果 不是第一次遇到pattern中的字符那就检查  映射的字符串和str[i]是不是相等的即可</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">wordPattern</span><span class="params">(String pattern, String s)</span> </span>&#123;</span><br><span class="line">        String[] strings = s.split(<span class="string">&quot; &quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (pattern.length()!=strings.length)<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        Map&lt;Character,String&gt; map=<span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pattern.length(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">char</span> ch = pattern.charAt(i);</span><br><span class="line">            String firstValue=map.get(ch);</span><br><span class="line">            <span class="keyword">if</span> (firstValue!=<span class="keyword">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (!strings[i].equals(map.get(ch)))<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (map.containsValue(strings[i]))<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">else</span> map.put(ch,strings[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h3 id="36-有效的数独"><a href="#36-有效的数独" class="headerlink" title="36. 有效的数独"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/valid-sudoku/">36. 有效的数独</a></h3><p>判断一个 9x9 的数独是否有效。只需要根据以下规则，验证已经填入的数字是否有效即可。</p>
<ul>
<li>数字 1-9 在每一行只能出现一次。</li>
<li>数字 1-9 在每一列只能出现一次。</li>
<li>数字 1-9 在每一个以粗实线分隔的 3x3 宫内只能出现一次。</li>
</ul>
<p><img src="https://image.duckflew.cn/img/blog_inner_image20201206205914.png" alt="250px-Sudoku-by-L2G-20050714.svg"></p>
<p>这个题中 有三种情况 行 列 和小数独块  分别为他们设置三个哈希表数组</p>
<p>行  : rowMap=hashMap[9]</p>
<p>列 : colMap=hashMap[9]</p>
<p>子图: sonGraphMap=hashMap[9]</p>
<p>然后对图进行遍历 遍历的过程中 对于点 i j 直接把他映射到对应的map中去  rowMap[i].put colMap[j].put  当然了如果已经存在这个字符了 那就直接返回false了</p>
<p>这里计算子图hashmap数组的下标  是用的如下表达式</p>
<p>sonGraphIndex=i/3*3+j/3</p>
<p>sonGraphMap[sonGraphIndex].put 就行了    这样做时间短一点  但是用了很多空间</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValidSudoku</span><span class="params">(<span class="keyword">char</span>[][]board)</span></span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">       HashMap&lt;Character,Integer&gt; [] rowMap=<span class="keyword">new</span> HashMap[<span class="number">9</span>];</span><br><span class="line">       HashMap&lt;Character,Integer&gt; [] colMap=<span class="keyword">new</span> HashMap[<span class="number">9</span>];</span><br><span class="line">       HashMap&lt;Character,Integer&gt; [] sonGraphMap=<span class="keyword">new</span> HashMap[<span class="number">9</span>];</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span>; i++) &#123;</span><br><span class="line">           rowMap[i] = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">           colMap[i] = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">           sonGraphMap[i] = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span>; i++)</span><br><span class="line">       &#123;</span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">9</span>; j++)</span><br><span class="line">           &#123;</span><br><span class="line">               <span class="keyword">char</span> cur=board[i][j];</span><br><span class="line">               <span class="keyword">if</span> (cur!=<span class="string">&#x27;.&#x27;</span>)</span><br><span class="line">               &#123;</span><br><span class="line">                   <span class="keyword">if</span> (rowMap[i].get(cur)!=<span class="keyword">null</span>)<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                   rowMap[i].put(cur,<span class="number">1</span>);</span><br><span class="line">                   <span class="keyword">if</span> (colMap[j].get(cur)!=<span class="keyword">null</span>)<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                   colMap[j].put(cur,<span class="number">1</span>);</span><br><span class="line">                   <span class="keyword">int</span> sonGraphMapIndex=(i/<span class="number">3</span>)*<span class="number">3</span>+j/<span class="number">3</span>;</span><br><span class="line">                   <span class="keyword">if</span> (sonGraphMap[sonGraphMapIndex].get(cur)!=<span class="keyword">null</span>)<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                   sonGraphMap[sonGraphMapIndex].put(cur,<span class="number">1</span>);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>



<h3 id="3-无重复字符的最长子串"><a href="#3-无重复字符的最长子串" class="headerlink" title="3. 无重复字符的最长子串"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/">3. 无重复字符的最长子串</a></h3><p>给定一个字符串，请你找出其中不含有重复字符的 <strong>最长子串</strong> 的长度。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: s = &quot;abcabcbb&quot;</span><br><span class="line">输出: 3 </span><br><span class="line">解释: 因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度为 3。</span><br></pre></td></tr></table></figure>

<p>思路：用一个hashmap把每个字母一次出现的位置记录下来并且维护一个curheadIndex指针  用来计算当前的子串的长度 当前的i-curheadIndex+1就是当前子串的长度 每一次计算之后都更新一下maxLength变量</p>
<p>在遍历的时候 如果当前的 字符已经出现过 说明curHeadIndex只能从这个字符出现过的位置的下一个位置 当然并不是在这个时候就直接把curHeadIndex赋值为 <code>map.get(ch) + 1</code>还是要首先判断一下这个位置是不是比我当前的curhead的位置大  curheadindex不能后退  例如 给出输入”abba” 如果不判断的话 curheadIndex的变化如下</p>
<p>a 第一次出现  curheadindex不变 还是0</p>
<p>b 第一次出现 curheadindex不变 还是0 </p>
<p>b 第二次出现 curheadindex修改为 2</p>
<p>a 第二次出现 curheadindex 修改为1</p>
<p>最后一次修改就不对了  因为此时 i=3  对应的子串是bba不符合条件   所以在保持curHeadIndex不后退的情况下一直保持下去那子串就是没有重复字符的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s==<span class="keyword">null</span>||s.length() == <span class="number">0</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    Map&lt;Character,Integer&gt;map=<span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">int</span> maxLength=Integer.MIN_VALUE;</span><br><span class="line">    <span class="keyword">int</span> curHeadIndex=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        Character ch=s.charAt(i);</span><br><span class="line">        <span class="keyword">if</span> (map.get(ch) != <span class="keyword">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (map.get(ch)+<span class="number">1</span>&gt;curHeadIndex)</span><br><span class="line">                curHeadIndex = map.get(ch) + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        map.put(ch,i);</span><br><span class="line">        maxLength=Math.max(maxLength,i-curHeadIndex+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxLength;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="503-下一个更大元素"><a href="#503-下一个更大元素" class="headerlink" title="503. 下一个更大元素||"></a>503. 下一个更大元素||</h3><p>在496题的基础 把数改成了循环数组  要求输出每一个元素对应的右侧的最大近更大的元素<br> 几乎是一样的做法  但是需要循环两遍 而且第二遍不需要push i 了因为第一遍 如果i 能够如栈就已经入栈了  第二遍只是检查在循环的情况下 如果栈里面有剩余元素  看能否再次找到一些有下一个更大元素的  相当于栈内的元素 在第二次遍历前还是有机会找到自己的下一个更大元素 的 原因就是这是一个循环数组<br>6 3  4 5 5  第一次遍历  栈里面肯定还剩余  6 5 5 (应该是写下标的 这里为了表达的清楚就直接写了元素) 然后第二次遍历  5 5 就可以出栈进行记录 了6最后剩余在栈里面因此得到的 res=[-1, 4, 5, 6, 6]<br>代码如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span>  <span class="keyword">int</span>[] nextGreaterElements(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        Stack&lt;Integer&gt; stack=<span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span>[] res=<span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">             <span class="keyword">while</span> (!stack.isEmpty()&amp;&amp;nums[i]&gt;nums[stack.lastElement()])</span><br><span class="line">             &#123;</span><br><span class="line">                 <span class="keyword">int</span> topIndex=stack.pop();</span><br><span class="line">                 res[topIndex]=nums[i];</span><br><span class="line">             &#125;</span><br><span class="line">             stack.push(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (stack.isEmpty())<span class="keyword">return</span> res;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span> (!stack.isEmpty()&amp;&amp;nums[i]&gt;nums[stack.lastElement()])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> topIndex=stack.pop();</span><br><span class="line">                res[topIndex]=nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty())</span><br><span class="line">        &#123;</span><br><span class="line">            res[stack.pop()]=-<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="496-下一个更大元素"><a href="#496-下一个更大元素" class="headerlink" title="496.下一个更大元素"></a>496.下一个更大元素</h3><blockquote>
<p>给定两个 没有重复元素 的数组 nums1 和 nums2 ，其中nums1 是 nums2 的子集。找到 nums1 中每个元素在 nums2 中的下一个比其大的值。<br>nums1 中数字 x 的下一个更大元素是指 x 在 nums2 中对应位置的右边的第一个比 x 大的元素。如果不存在，对应位置输出 -1 </p>
</blockquote>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: nums1 = [4,1,2], nums2 = [1,3,4,2].</span><br><span class="line">输出: [-1,3,-1]</span><br></pre></td></tr></table></figure>
<p>这是个单调栈的问题 跟下面的每日温度属于同一个类型的题  既然nums1是nums2的子集然后找到右侧的第一个比当前元素大的元素 那只需要设置一个栈 然后遍历nums2 维持这个栈为一个从栈底到栈顶递减的栈 例如上面的例子过程如下<br>首先因为是空 1 入栈 然后3 比1 大  1出栈  这里就表示1右边的第一个比他大的元素就是3 用一个hashmap的键值对存储起来  1-&gt;3 ，然后3 入栈  接下来是4 4比3大  3出栈  map放入3-&gt;4 然后4入栈 下面是 2  直接入栈<br>那对于 4 1 2 得到的res数组就是  -1 3 2  因为4,和1  还在栈里面并没有存储到map 那map如果get不到这个值 就直接让对应的res[i]=-1就行了  下面是代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] nextGreaterElement(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span>[] nums2) &#123;</span><br><span class="line">        <span class="keyword">int</span> res[]=<span class="keyword">new</span> <span class="keyword">int</span>[nums1.length];</span><br><span class="line">        Stack&lt;Integer&gt; stack=<span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        Map&lt;Integer,Integer&gt; firstNumBigThanNum=<span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums2.length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> cur=nums2[i];</span><br><span class="line">            <span class="keyword">while</span> (!stack.isEmpty()&amp;&amp;stack.lastElement()&lt;cur)</span><br><span class="line">            &#123;</span><br><span class="line">                firstNumBigThanNum.put(stack.pop(),cur);</span><br><span class="line">            &#125;</span><br><span class="line">            stack.push(cur);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums1.length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            Integer get = firstNumBigThanNum.get(nums1[i]);</span><br><span class="line">            res[i]=get!=<span class="keyword">null</span>?get:-<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="522-设计循环队列"><a href="#522-设计循环队列" class="headerlink" title="522.设计循环队列"></a>522.设计循环队列</h3><p>利用数组实现 设置两个值 head 和tail 每一个时刻<br><code>tail=(head+size)%capacity</code><br>size表示队列的元素个数  capacity表示队列的最大容量 在返回rear队尾元素时候 返回的是tail的前一个元素</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> index=tail-<span class="number">1</span>&lt;<span class="number">0</span>?(tail-<span class="number">1</span>+capacity):tail-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> queue[index];</span><br></pre></td></tr></table></figure>
<p>下面是全部代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyCircularQueue</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] queue;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> capacity;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> head;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> tail;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyCircularQueue</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        queue=<span class="keyword">new</span> <span class="keyword">int</span>[k];</span><br><span class="line">        size=<span class="number">0</span>;</span><br><span class="line">        head=<span class="number">0</span>;</span><br><span class="line">        tail=<span class="number">0</span>;</span><br><span class="line">        capacity=k;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">enQueue</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (size==capacity)<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        queue[tail]=value;</span><br><span class="line">        size++;</span><br><span class="line">        tail=(head+size)%capacity;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">deQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (size==<span class="number">0</span>)<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        size--;</span><br><span class="line">        head=(head+<span class="number">1</span>)%capacity;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">Front</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (size==<span class="number">0</span>)<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> queue[head];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">Rear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (size==<span class="number">0</span>)<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> index=tail-<span class="number">1</span>&lt;<span class="number">0</span>?(tail-<span class="number">1</span>+capacity):tail-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> queue[index];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> size==<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isFull</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> size==capacity;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//    public void show()</span></span><br><span class="line"><span class="comment">//    &#123;</span></span><br><span class="line"><span class="comment">//        if (size==0)System.out.println(&quot;null&quot;);</span></span><br><span class="line"><span class="comment">//        else</span></span><br><span class="line"><span class="comment">//        &#123;</span></span><br><span class="line"><span class="comment">//            System.out.println(&quot;head=&quot;+head+&quot;    tail=&quot;+tail+&quot;   size=&quot;+size) ;</span></span><br><span class="line"><span class="comment">//            do</span></span><br><span class="line"><span class="comment">//            &#123;</span></span><br><span class="line"><span class="comment">//                if (head &gt;= capacity) head = head % capacity;</span></span><br><span class="line"><span class="comment">//                System.out.print(queue[head++] + &quot; &quot;);</span></span><br><span class="line"><span class="comment">//            &#125; while (head != tail);</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="232-用两个栈来实现队列"><a href="#232-用两个栈来实现队列" class="headerlink" title="232.用两个栈来实现队列"></a>232.用两个栈来实现队列</h3><p>一个栈inStack 一个outStack  一个顺序的队列进栈出栈再进栈 顺序不变<br>push的时候 如果out里面没有元素了 那就把in里面所有的元素送到out 否则的直接push到In即可<br>pop的时候要看out是否为空 如果为空  就要把in的所有元素都添加过来 然后在Pop<br>总之就是以out优先  因为out里面的顺序才是元素添加进来的真实顺序才满足队列的要求</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyQueue</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Stack&lt;Integer&gt; inStack;</span><br><span class="line">    <span class="keyword">private</span> Stack&lt;Integer&gt; outStack;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        inStack=<span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        outStack=<span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (outStack.isEmpty())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span> (!inStack.isEmpty())</span><br><span class="line">            &#123;</span><br><span class="line">                outStack.push(inStack.pop());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        inStack.push(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (outStack.isEmpty())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span> (!inStack.isEmpty())</span><br><span class="line">            &#123;</span><br><span class="line">                outStack.push(inStack.pop());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> outStack.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (outStack.isEmpty())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span> (!inStack.isEmpty())</span><br><span class="line">            &#123;</span><br><span class="line">                outStack.push(inStack.pop());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> outStack.lastElement();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> inStack.isEmpty()&amp;&amp;outStack.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="225-用两个队列实现栈"><a href="#225-用两个队列实现栈" class="headerlink" title="225.用两个队列实现栈"></a>225.用两个队列实现栈</h3><p>思路 一个主队列 一个副队列<br>当有元素要push进来的时候 直接加入在主队列后面<br>如果要pop的时候先让主队列依次poll到副队列  然后让队列尾部的元素poll 再把副队列的的元素挪回来  相当于前面的人暂时消失 队尾的人打到饭走了  然后前面的人回来了<br>peek也是同理  empty的话  两个队列都是空就返回empty就行了</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">while</span> (mainQueue.size()&gt;<span class="number">1</span>)</span><br><span class="line">      &#123;</span><br><span class="line">          viceQueue.add(mainQueue.poll());</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">int</span> popRes=mainQueue.poll();</span><br><span class="line">      <span class="keyword">while</span> (!viceQueue.isEmpty())</span><br><span class="line">      &#123;</span><br><span class="line">          mainQueue.add(viceQueue.poll());</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> popRes;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h3 id="155-最小栈"><a href="#155-最小栈" class="headerlink" title="155 最小栈"></a>155 最小栈</h3><blockquote>
<p>设计一个支持 push ，pop ，top 操作，并能在常数时间内检索到最小元素的栈。</p>
</blockquote>
<p>思路就是 除了基本的数据栈 还增加一个 辅助栈  minDataStack<br><code>push</code>的话就是   如果需要push的话  当然是先入数据栈 然后判断<br> 小于等于辅助栈 栈顶元素  那就入栈  为什么是小于等于呢  考虑如下的情况  假设不是小于等于而是小于的情况下 push 100 87 87  那我的辅助栈就处于现在的情况了100 87 然后假设我Pop87   现在  数据栈还剩余100 和87  但是辅助栈剩余 100  显示的当前的最小值就是100  当然是不行的<br><code>pop</code>的话  就是pop当前的元素 并且和辅助栈栈顶部的元素比较 如果等于栈顶的元素 说明这就是一个最小值 需要把<code>minDataStack</code>也<code>pop</code>掉  其他的没什么好说的 要获取当前的最小值的话就是<code>return minDataStack.lastElement</code>就行了</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        s.push(x);</span><br><span class="line">        <span class="keyword">if</span> (minData.isEmpty()||x&lt;=minData.lastElement())minData.push(x);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (minData.lastElement().equals(s.pop()))minData.pop();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="739-每日温度"><a href="#739-每日温度" class="headerlink" title="739.每日温度"></a>739.每日温度</h3><blockquote>
<p>请根据每日 气温 列表，重新生成一个列表。对应位置的输出为：要想观测到更高的气温，至少需要等待的天数。如果气温在这之后都不会升高，请在该位置用 0 来代替。<br>例如，给定一个列表 temperatures = [73, 74, 75, 71, 69, 72, 76, 73]，你的输出应该是 [1, 1, 4, 2, 1, 1, 0, 0]</p>
</blockquote>
<p>这个题首先遍历T数组<br>设置一个栈  来存储每个温度对应的下标索引值 并且这些索引对应的温度体现在这个栈内部应该是一个温度递减的栈 为什么要温度递减？ 因为我们要求的是接下来的多少天能够使得温度升高  那就只要把中间一直在递减的温度的索引一直存进去 知道遇到某个索引时 他对应的温度不满足递减了  那就用这个索引减去栈内部的索引得到的差值就是需要的天数  注意点 如果当前的温度一直比栈顶对应的温度高 那就要一直pop并且把对应的天数存储到结果数组里面去  举例如下<br>[73, 74, 75, 71, 69, 72, 76, 73] 这个温度序列   遍历它<br>t=73  stack empty 0入栈<br>t=74  比栈顶0对应的温度高  那就把0出栈 res[0]=1(74的索引)-0=1;<br>然后把 74的索引入栈 1  因为栈已经空了  否则还要继续比下去<br>t=75  同样的  74对应的1 出栈  75的2进栈 res[1]=1;<br>然后就是 71 69 他们是递减的  直接入栈即可<br>然后就是   72  那 71 69就要出栈  并且在res的的对应位置上赋值 值就是72的索引减去他们各自的索引  然后72 入栈  此时栈内还剩 2对应温度75,5(对应温度72）  然后继续进行下去就可以了<br><strong>最后还需要判断一下</strong>  栈里面还没有元素  还有的话依次把他们出栈 并且他们的对应的res的值为0 表示的就是自这个温度以后找不到更高的温度了 那就只能是0</p>
<h3 id="240-搜索二维矩阵"><a href="#240-搜索二维矩阵" class="headerlink" title="240.搜索二维矩阵"></a>240.搜索二维矩阵</h3><p>在一个有规律的矩阵中搜索特定的值<br>这个矩阵的规律如下</p>
<ul>
<li>每行的元素从左到右升序排列。</li>
<li>每列的元素从上到下升序排列。</li>
</ul>
<p><strong>解法1</strong></p>
<p>逐行遍历 二分搜索  每次遍历先判断一下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (matrix[i][<span class="number">0</span>]&gt;target)<span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">if</span> (matrix[i][matrix[i].length-<span class="number">1</span>]&lt;target)<span class="keyword">continue</span>;</span><br></pre></td></tr></table></figure>

<p>如果本行的第一个元素大于target 这一行就不用看了</p>
<p>如果本行的最后一个元素小于target 这一行也不用看了</p>
<p> 算是个小的优化</p>
<p><strong>解法2</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">数组从左到右和从上到下都是升序的，如果从右上角出发开始遍历呢？</span><br><span class="line"></span><br><span class="line">会发现每次都是向左数字会变小，向下数字会变大，有点和二分查找树相似。二分查找树的话，是向左数字变小，向右数字变大。</span><br><span class="line"></span><br><span class="line">所以我们可以把 target 和当前值比较。</span><br><span class="line"></span><br><span class="line">如果 target 的值大于当前值，那么就向下走。</span><br><span class="line">如果 target 的值小于当前值，那么就向左走。</span><br><span class="line">如果相等的话，直接返回 <span class="keyword">true</span> 。</span><br><span class="line">也可以换个角度思考。</span><br><span class="line"></span><br><span class="line">如果 target 的值小于当前值，也就意味着当前值所在的列肯定不会存在 target 了，可以把当前列去掉，从新的右上角的值开始遍历。</span><br><span class="line"></span><br><span class="line">同理，如果 target 的值大于当前值，也就意味着当前值所在的行肯定不会存在 target 了，可以把当前行去掉，从新的右上角的值开始遍历。</span><br><span class="line"></span><br><span class="line">看下边的例子。</span><br><span class="line">[<span class="number">2</span>,   <span class="number">5</span>,  <span class="number">8</span>, <span class="number">12</span>, <span class="number">19</span>],</span><br><span class="line">[<span class="number">3</span>,   <span class="number">6</span>,  <span class="number">9</span>, <span class="number">16</span>, <span class="number">22</span>],</span><br><span class="line">[<span class="number">10</span>, <span class="number">13</span>, <span class="number">14</span>, <span class="number">17</span>, <span class="number">24</span>],</span><br><span class="line">[<span class="number">18</span>, <span class="number">21</span>, <span class="number">23</span>, <span class="number">26</span>, <span class="number">30</span>]</span><br><span class="line"></span><br><span class="line">如果 target  = <span class="number">9</span>，如果我们从 <span class="number">15</span> 开始遍历, cur = <span class="number">15</span></span><br><span class="line">    </span><br><span class="line">target &lt; <span class="number">15</span>, 去掉当前列, cur = <span class="number">11</span></span><br><span class="line">[<span class="number">1</span>,   <span class="number">4</span>,  <span class="number">7</span>, <span class="number">11</span>],</span><br><span class="line">[<span class="number">2</span>,   <span class="number">5</span>,  <span class="number">8</span>, <span class="number">12</span>],</span><br><span class="line">[<span class="number">3</span>,   <span class="number">6</span>,  <span class="number">9</span>, <span class="number">16</span>],</span><br><span class="line">[<span class="number">10</span>, <span class="number">13</span>, <span class="number">14</span>, <span class="number">17</span>],</span><br><span class="line">[<span class="number">18</span>, <span class="number">21</span>, <span class="number">23</span>, <span class="number">26</span>]    </span><br><span class="line">    </span><br><span class="line">target &lt; <span class="number">11</span>, 去掉当前列, cur = <span class="number">7</span>  </span><br><span class="line">[<span class="number">1</span>,   <span class="number">4</span>,  <span class="number">7</span>],</span><br><span class="line">[<span class="number">2</span>,   <span class="number">5</span>,  <span class="number">8</span>],</span><br><span class="line">[<span class="number">3</span>,   <span class="number">6</span>,  <span class="number">9</span>],</span><br><span class="line">[<span class="number">10</span>, <span class="number">13</span>, <span class="number">14</span>],</span><br><span class="line">[<span class="number">18</span>, <span class="number">21</span>, <span class="number">23</span>]     </span><br><span class="line"></span><br><span class="line">target &gt; <span class="number">7</span>, 去掉当前行, cur = <span class="number">8</span>   </span><br><span class="line">[<span class="number">2</span>,   <span class="number">5</span>,  <span class="number">8</span>],</span><br><span class="line">[<span class="number">3</span>,   <span class="number">6</span>,  <span class="number">9</span>],</span><br><span class="line">[<span class="number">10</span>, <span class="number">13</span>, <span class="number">14</span>],</span><br><span class="line">[<span class="number">18</span>, <span class="number">21</span>, <span class="number">23</span>]       </span><br><span class="line"></span><br><span class="line">target &gt; <span class="number">8</span>, 去掉当前行, cur = <span class="number">9</span>, 遍历结束    </span><br><span class="line">[<span class="number">3</span>,   <span class="number">6</span>,  <span class="number">9</span>],</span><br><span class="line">[<span class="number">10</span>, <span class="number">13</span>, <span class="number">14</span>],</span><br><span class="line">[<span class="number">18</span>, <span class="number">21</span>, <span class="number">23</span>]   </span><br></pre></td></tr></table></figure>

<p>代码如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">if</span> (matrix==<span class="keyword">null</span>||matrix.length==<span class="number">0</span>||matrix[<span class="number">0</span>].length==<span class="number">0</span>)<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">int</span> curCol=matrix[<span class="number">0</span>].length-<span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> curRow=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> cur;</span><br><span class="line"><span class="keyword">while</span> (curCol&gt;=<span class="number">0</span>&amp;&amp;curRow&lt;matrix.length)</span><br><span class="line">&#123;</span><br><span class="line">    cur=matrix[curRow][curCol];</span><br><span class="line">    <span class="keyword">if</span> (cur==target)<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (cur&gt;target) curCol--;</span><br><span class="line">    <span class="keyword">else</span> curRow++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br></pre></td></tr></table></figure>


<h3 id="283-移动0"><a href="#283-移动0" class="headerlink" title="283. 移动0"></a>283. 移动0</h3><blockquote>
<p>给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [0,1,0,3,12]</span><br><span class="line">输出: [1,3,12,0,0]</span><br></pre></td></tr></table></figure>

<p><strong>思路</strong>:可以把这个数组当成一条路，两个指针（i,j），相当于两个人，其中i具有飞行能力，j没有，这条路0相当于一条河（i可以飞过去，j不行），所以当碰到河（0）时，i飞过去了，j就停在河边，当i碰到非0（陆地）时，他会将这个陆地（非0）复制到j的前面让j前进。<br>这样一个过程下来，i会将这条路（数组）走完，j会停留在河流（0）或者重复陆地（非0）边。此时j的后面就是重复的数字或者0了，直接for赋值为0即可</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">moveZeroes</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">if</span> (nums==<span class="keyword">null</span>||nums.length==<span class="number">0</span>)<span class="keyword">return</span> ;</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> j=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (;i&lt;nums.length;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i]!=<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                nums[j++]=nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (;j&lt;nums.length;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            nums[j]=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="566-重塑矩阵"><a href="#566-重塑矩阵" class="headerlink" title="566.重塑矩阵"></a>566.重塑矩阵</h3><p>先判断 重塑前的总元素个数是否等于需要重塑后的尺寸 相等的话 遍历二维数组依次填充即可<br>填充方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[][] newNums = <span class="keyword">new</span> <span class="keyword">int</span>[r][c];</span><br><span class="line">        <span class="keyword">int</span> newRow=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> newCol=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;nums[i].length;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                newNums[newRow][newCol++]=nums[i][j];</span><br><span class="line">                <span class="keyword">if</span> (newCol==c)</span><br><span class="line">                &#123;</span><br><span class="line">                    newCol=<span class="number">0</span>;</span><br><span class="line">                    newRow++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="keyword">return</span>  newNums;</span><br></pre></td></tr></table></figure>

<h3 id="697-数组的度"><a href="#697-数组的度" class="headerlink" title="697.数组的度"></a>697.数组的度</h3><blockquote>
<p>题目:  给定一个非空且只包含非负数的整数数组 nums, 数组的度的定义是指数组里任一元素出现频数的最大值。<br>你的任务是找到与 nums 拥有相同大小的度的最短连续子数组，返回其长度。</p>
</blockquote>
<blockquote>
<p>思路:具有度数 d 的数组必须有一些元素 x 出现 d 次。如果某些子数组具有相同的度数，那么某些元素 x （出现 d 次）。最短的子数组是将从 x 的第一次出现到最后一次出现的数组。<br>对于给定数组中的每个元素，让我们知道 left 是它第一次出现的索引； right 是它最后一次出现的索引。例如，当 nums = [1,2,3,2,5] 时，left[2] = 1 和 right[2] = 3。<br>然后，对于出现次数最多的每个元素 x，right[x] - left[x] + 1 将是我们的候选答案，我们将取这些候选的最小值。</p>
</blockquote>
<p>一个map left放第一次出现的位置 一个right 放最后一次出现的位置 一个counts放每个数字出现的次数<br>遍历数组 right存入当前的数字以及位置  因为存储的最后的位置 只需要不断覆盖就行   然后判断left.get(当前数字)是不是为空 是的话存入当前位置并且设置count=1 后面每次不为空的时候就更新count 更新方法就是先取出然后覆盖 官方有一个小技巧写法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">counts.put(cur,counts.getOrDefault(cur,<span class="number">0</span>)+<span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<p>代码:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;Integer,Integer&gt; left=<span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">       Map&lt;Integer,Integer&gt;  right=<span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">       Map&lt;Integer,Integer&gt;  counts=<span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)</span><br><span class="line">       &#123;</span><br><span class="line">           <span class="keyword">int</span> cur=nums[i];</span><br><span class="line">           right.put(cur,i);</span><br><span class="line">           <span class="keyword">if</span> (left.get(cur)!=<span class="keyword">null</span>)</span><br><span class="line">           &#123;</span><br><span class="line">               Integer count = counts.get(cur);</span><br><span class="line">               counts.put(cur,count+<span class="number">1</span>);</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">else</span></span><br><span class="line">           &#123;</span><br><span class="line">               left.put(cur,i);</span><br><span class="line">               counts.put(cur,<span class="number">1</span>);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       Integer maxCount = Collections.max(counts.values());</span><br><span class="line">       <span class="keyword">int</span> res=nums.length;</span><br><span class="line">       <span class="keyword">for</span> (Integer key:counts.keySet())</span><br><span class="line">       &#123;</span><br><span class="line">           <span class="keyword">if</span> (counts.get(key).equals(maxCount))</span><br><span class="line">           &#123;</span><br><span class="line">               res=Math.min(res,right.get(key)-left.get(key)+<span class="number">1</span>);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> res;</span><br></pre></td></tr></table></figure>

<h3 id="1365-求数组中有多少小于当前数字的数字"><a href="#1365-求数组中有多少小于当前数字的数字" class="headerlink" title="1365.求数组中有多少小于当前数字的数字"></a>1365.求数组中有多少小于当前数字的数字</h3><p>思路 用一个哈希表来存储<br><code>Map&lt;Integer,HashSet()&gt;indexOfValues</code><br>复制一份原数组  进行排序  排序完成后 对于每一个元素我的索引是多少 就有多少数字比我小 我只需要把每个数字对应的排序后的索引存储到indexOfValues的对应的key的hashset中   然后遍历原数组  对于每一个元素  找到这个元素对应的装索引的HashSet  取最小的值  就是小于这个数字的数字的个数<br>代码如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> len=nums.length;</span><br><span class="line">       Map&lt;Integer, HashSet&lt;Integer&gt;&gt;indexOfValues=<span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">       <span class="keyword">int</span>[] newNums = Arrays.copyOf(nums, len);</span><br><span class="line">       Arrays.sort(newNums);</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;newNums.length;i++)</span><br><span class="line">       &#123;</span><br><span class="line">           <span class="keyword">int</span> cur=newNums[i];</span><br><span class="line">           HashSet&lt;Integer&gt; indexSet = indexOfValues.getOrDefault(cur,<span class="keyword">new</span> HashSet&lt;&gt;());</span><br><span class="line">           indexSet.add(i);</span><br><span class="line">           indexOfValues.put(cur,indexSet);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">int</span>[] res=<span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)</span><br><span class="line">       &#123;</span><br><span class="line">           <span class="keyword">int</span> cur=nums[i];</span><br><span class="line">           Integer min = Collections.min(indexOfValues.get(cur));</span><br><span class="line">           res[i]=min;</span><br><span class="line">       &#125;</span><br><span class="line"> <span class="keyword">return</span> res;</span><br></pre></td></tr></table></figure>

<h3 id="766-托普利茨矩阵"><a href="#766-托普利茨矩阵" class="headerlink" title="766.托普利茨矩阵"></a>766.托普利茨矩阵</h3><blockquote>
<p>如果矩阵上每一条由左上到右下的对角线上的元素都相同，那么这个矩阵是 托普利茨矩阵 。<br>例如<br>[1,2,3,4],<br>[5,1,2,3],<br>[9,5,1,2]<br>给定一个 M x N 的矩阵，当且仅当它是托普利茨矩阵时返回 True。</p>
</blockquote>
<p>思路:同一条对角线 有一个直线表达式  例如最长的对角线就满足j-i=0;<br>我们将j-i所有可以取到的值放入map 并且从第一排和第一列取一个验证值放进去作为value 然后遍历整个矩阵  如果i行j列的元素不等于map.get(j-i)中取出来的value验证值 说明不是托普利茨矩阵</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;Integer,Integer&gt; dataOfEveryLine=<span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;matrix[<span class="number">0</span>].length;j++)</span><br><span class="line">       &#123;</span><br><span class="line">           dataOfEveryLine.put(j-<span class="number">0</span>,matrix[<span class="number">0</span>][j]);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;matrix.length;i++)</span><br><span class="line">       &#123;</span><br><span class="line">           dataOfEveryLine.put(<span class="number">0</span>-i,matrix[i][<span class="number">0</span>]);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; matrix.length; i++)</span><br><span class="line">       &#123;</span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; matrix[i].length; j++)</span><br><span class="line">           &#123;</span><br><span class="line">               <span class="keyword">if</span> (matrix[i][j]!=dataOfEveryLine.get(j-i))<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">true</span>;</span><br></pre></td></tr></table></figure>

<h3 id="645-错误的集合"><a href="#645-错误的集合" class="headerlink" title="645.错误的集合"></a>645.错误的集合</h3><blockquote>
<p>集合 S 包含从1到 n 的整数。不幸的是，因为数据错误，导致集合里面某一个元素复制了成了集合里面的另外一个元素的值，导致集合丢失了一个整数并且有一个元素重复。</p>
</blockquote>
<p>给定一个数组 nums 代表了集合 S 发生错误后的结果。你的任务是首先寻找到重复出现的整数，再找到丢失的整数，将它们以数组的形式返回。<br>示例 1:<br>输入: nums = [1,2,2,4]<br>输出: [2,3]</p>
<p>思路:<br>第一次遍历数组  对于每个数组元素 这个元素-1一定会对应一个唯一的下表 除了那个重复的元素  所以我们通过这个下标来把第一次访问的元素置为负数 这样遍历下去 如果发现 某一次通过当前的元素值-1得到的下标 已经是个负数了 说明这个值的绝对值对应的就是重复的元素  存储下来即可 不需要进行改变 这个过程中总共 置负了length-1次  有一次是判断到负数了  所以必然有一个值没有被赋值 这个值的下标+1就是缺失的元素了<br>第二次遍历数组 只需要找到是正数的那个元素<br>注意点:在取元素然后-1作为下标的时候其实要取的是元素的绝对值</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> repeatNum = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//System.out.println(Arrays.toString(nums));</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)</span><br><span class="line">        &#123;</span><br><span class="line">           <span class="keyword">int</span> cur=nums[i];</span><br><span class="line">           <span class="keyword">if</span> (nums[Math.abs(cur)-<span class="number">1</span>]&gt;<span class="number">0</span>)nums[Math.abs(cur)-<span class="number">1</span>]*=-<span class="number">1</span>;</span><br><span class="line">           <span class="keyword">else</span></span><br><span class="line">           &#123;</span><br><span class="line">               repeatNum=Math.abs(cur);</span><br><span class="line">           &#125;</span><br><span class="line">         <span class="comment">//System.out.println(Arrays.toString(nums));</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> missing = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i]&gt;<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                missing=i+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;repeatNum,missing&#125;;</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="https://129duckflew.github.io/2021/03/21/leetcode%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/" data-id="ckmjbdb9g000gm4ve3bbsddme" data-title="leetcode刷题记录" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-LeetCode 笔记--分治法" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/03/21/LeetCode%20%E7%AC%94%E8%AE%B0--%E5%88%86%E6%B2%BB%E6%B3%95/" class="article-date">
  <time class="dt-published" datetime="2021-03-21T15:31:56.836Z" itemprop="datePublished">2021-03-21</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/03/21/LeetCode%20%E7%AC%94%E8%AE%B0--%E5%88%86%E6%B2%BB%E6%B3%95/">LeetCode 笔记--分治法</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="LeetCode-笔记–分治法"><a href="#LeetCode-笔记–分治法" class="headerlink" title="LeetCode 笔记–分治法"></a>LeetCode 笔记–分治法</h1><h4 id="23-合并K个升序链表"><a href="#23-合并K个升序链表" class="headerlink" title="23. 合并K个升序链表"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/merge-k-sorted-lists/">23. 合并K个升序链表</a></h4><p>难度困难1216</p>
<p>给你一个链表数组，每个链表都已经按升序排列。</p>
<p>请你将所有链表合并到一个升序链表中，返回合并后的链表。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">输入：lists &#x3D; [[1,4,5],[1,3,4],[2,6]]</span><br><span class="line">输出：[1,1,2,3,4,4,5,6]</span><br><span class="line">解释：链表数组如下：</span><br><span class="line">[</span><br><span class="line">  1-&gt;4-&gt;5,</span><br><span class="line">  1-&gt;3-&gt;4,</span><br><span class="line">  2-&gt;6</span><br><span class="line">]</span><br><span class="line">将它们合并到一个有序链表中得到。</span><br><span class="line">1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4-&gt;5-&gt;6</span><br></pre></td></tr></table></figure>

<p><strong>解答</strong></p>
<p>合并两个链表的方法很简单  数据结构的课上都讲过   对于这个题 首先想到的就是  写一个方法  来合并两个链表 然后把数组里面的链表一个个合并  但是这样做效率不高  分治法来合并  更优</p>
<p>也就是再写一个方法  把链表数组每次都再分一半  分了一半再递归  直到只剩一个  然后返回</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeKLists</span><span class="params">(ListNode[] lists)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mergeTwoLists(lists,<span class="number">0</span>,lists.length-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeTwoLists</span><span class="params">(ListNode[] lists,<span class="keyword">int</span> left,<span class="keyword">int</span> right)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (left&gt;right)<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (left==right)<span class="keyword">return</span> lists[left];</span><br><span class="line">       ListNode leftLists=mergeTwoLists(lists,left,(left+right)/<span class="number">2</span>);</span><br><span class="line">        ListNode rightLists=mergeTwoLists(lists,(left+right)/<span class="number">2</span>+<span class="number">1</span>,right);</span><br><span class="line">        <span class="keyword">return</span> mergeTwoList(leftLists,rightLists);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">ListNode <span class="title">mergeTwoList</span><span class="params">(ListNode l1,ListNode l2)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l1==<span class="keyword">null</span>)<span class="keyword">return</span> l2;</span><br><span class="line">        <span class="keyword">if</span> (l2==<span class="keyword">null</span> )<span class="keyword">return</span> l1;</span><br><span class="line">        ListNode p1=l1;</span><br><span class="line">        ListNode p2=l2;</span><br><span class="line">        ListNode head=<span class="keyword">null</span>  ;</span><br><span class="line">        <span class="keyword">if</span> (p1.val&lt;=p2.val)</span><br><span class="line">        &#123;</span><br><span class="line">            head=p1;</span><br><span class="line">            p1=p1.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            head=p2;</span><br><span class="line">            p2=p2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode p3=head;</span><br><span class="line">        <span class="keyword">while</span> (p1!=<span class="keyword">null</span>&amp;&amp;p2!=<span class="keyword">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (p1.val&lt;=p2.val)</span><br><span class="line">            &#123;</span><br><span class="line">                p3.next=p1;</span><br><span class="line">                p1=p1.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                p3.next=p2;</span><br><span class="line">                p2=p2.next;</span><br><span class="line">            &#125;</span><br><span class="line">            p3=p3.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (p1!=<span class="keyword">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            p3.next=p1;</span><br><span class="line">            p1=p1.next;</span><br><span class="line">            p3=p3.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (p2!=<span class="keyword">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            p3.next=p2;</span><br><span class="line">            p2=p2.next;</span><br><span class="line">            p3=p3.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="https://129duckflew.github.io/2021/03/21/LeetCode%20%E7%AC%94%E8%AE%B0--%E5%88%86%E6%B2%BB%E6%B3%95/" data-id="ckmjbdb910002m4vehfvr1ke6" data-title="LeetCode 笔记--分治法" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-LeetCode 笔记----DP问题" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/03/21/LeetCode%20%E7%AC%94%E8%AE%B0----DP%E9%97%AE%E9%A2%98/" class="article-date">
  <time class="dt-published" datetime="2021-03-21T15:31:56.834Z" itemprop="datePublished">2021-03-21</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/03/21/LeetCode%20%E7%AC%94%E8%AE%B0----DP%E9%97%AE%E9%A2%98/">LeetCode 笔记----DP问题</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="LeetCode-笔记—-DP问题"><a href="#LeetCode-笔记—-DP问题" class="headerlink" title="LeetCode 笔记—-DP问题"></a>LeetCode 笔记—-DP问题</h1><h4 id="64-最小路径和"><a href="#64-最小路径和" class="headerlink" title="64. 最小路径和"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/minimum-path-sum/">64. 最小路径和</a></h4><p>给定一个包含非负整数的 <code>*m* x *n*</code> 网格 <code>grid</code> ，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。</p>
<p><strong>说明：</strong>每次只能向下或者向右移动一步。</p>
<p><strong>示例 1：</strong></p>
<p><img src="https://image.duckflew.cn/img/blog_inner_image20210319200156.jpeg" alt="img"></p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：grid = [[1,3,1],[1,5,1],[4,2,1]]</span><br><span class="line">输出：7</span><br><span class="line">解释：因为路径 1→3→1→1→1 的总和最小。</span><br></pre></td></tr></table></figure>

<p><strong>解答:</strong></p>
<p>设置一个dp数组 dp[i][j] 表示  到  i  j 这个点的最小数字总和  然后考虑边界情况 ：起始点的dp值就是起始点的值  第一行的元素只能由左边的元素转移得到   第一列的元素只能由上面的元素转移得到    然后就是普通点要么从上面转移过来 要么从左边转移过来  取最小的<code>Math.min(dp[i-1][j],dp[i][j-1])</code>然后加上这个格子的值就是<code>dp[i][j]</code>了</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minPathSum</span><span class="params">(<span class="keyword">int</span>[][] grid)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span>[][]dp=<span class="keyword">new</span> <span class="keyword">int</span>[grid.length][grid[<span class="number">0</span>].length];</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; grid.length; i++)</span><br><span class="line">       &#123;</span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; grid[<span class="number">0</span>].length; j++)</span><br><span class="line">           &#123;</span><br><span class="line">               <span class="keyword">if</span> (i==<span class="number">0</span>&amp;&amp;j==<span class="number">0</span>)dp[i][j]=grid[i][j];  <span class="comment">//边界</span></span><br><span class="line">               <span class="keyword">else</span> <span class="keyword">if</span> (i==<span class="number">0</span>) dp[i][j]=dp[i][j-<span class="number">1</span>]+grid[i][j]; <span class="comment">//边界</span></span><br><span class="line">               <span class="keyword">else</span> <span class="keyword">if</span> (j==<span class="number">0</span>) dp[i][j]=dp[i-<span class="number">1</span>][j]+grid[i][j]; <span class="comment">//边界</span></span><br><span class="line">               <span class="keyword">else</span> dp[i][j]=Math.min(dp[i-<span class="number">1</span>][j],dp[i][j-<span class="number">1</span>])+grid[i][j];</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span>  dp[grid.length-<span class="number">1</span>][grid[<span class="number">0</span>].length-<span class="number">1</span>];</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h4 id="120-三角形最小路径和"><a href="#120-三角形最小路径和" class="headerlink" title="120. 三角形最小路径和"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/triangle/">120. 三角形最小路径和</a></h4><p>给定一个三角形 <code>triangle</code> ，找出自顶向下的最小路径和。</p>
<p>每一步只能移动到下一行中相邻的结点上。<strong>相邻的结点</strong> 在这里指的是 <strong>下标</strong> 与 <strong>上一层结点下标</strong> 相同或者等于 <strong>上一层结点下标 + 1</strong> 的两个结点。也就是说，如果正位于当前行的下标 <code>i</code> ，那么下一步可以移动到下一行的下标 <code>i</code> 或 <code>i + 1</code> 。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入：triangle = [[2],[3,4],[6,5,7],[4,1,8,3]]</span><br><span class="line">输出：11</span><br><span class="line">解释：如下面简图所示：</span><br><span class="line">   2</span><br><span class="line">  3 4</span><br><span class="line"> 6 5 7</span><br><span class="line">4 1 8 3</span><br><span class="line">自顶向下的最小路径和为 11（即，2 + 3 + 5 + 1 = 11）。</span><br></pre></td></tr></table></figure>

<p><strong>解答:</strong></p>
<p>这个题和上面的那个基本上类似 只是把二维数组改成了不定长的二维数组</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">   public int minimumTotal(List&lt;List&lt;Integer&gt;&gt; triangle) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; dp&#x3D;new ArrayList&lt;&gt;();</span><br><span class="line">        &#x2F;&#x2F;初始化二维  list</span><br><span class="line">        for (int i &#x3D; 0; i &lt; triangle.size(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            List&lt;Integer&gt; list&#x3D;new ArrayList&lt;&gt;();</span><br><span class="line">            dp.add(list);</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i &#x3D; 0; i &lt; triangle.size(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            List&lt;Integer&gt; line&#x3D;triangle.get(i);</span><br><span class="line">            for (int j &#x3D; 0; j &lt; line.size(); j++)</span><br><span class="line">            &#123;</span><br><span class="line">                int dpValue;</span><br><span class="line">                if (i&#x3D;&#x3D;0&amp;&amp;j&#x3D;&#x3D;0)</span><br><span class="line">                    dpValue&#x3D;line.get(j);</span><br><span class="line">                else if (j&#x3D;&#x3D;0)</span><br><span class="line">                    dpValue&#x3D;dp.get(i-1).get(j)+line.get(j);</span><br><span class="line">                else if (j&#x3D;&#x3D;i)</span><br><span class="line">                    dpValue&#x3D;dp.get(i-1).get(j-1)+line.get(j);</span><br><span class="line">                else dpValue&#x3D;Math.min(dp.get(i-1).get(j),dp.get(i-1).get(j-1))+line.get(j);</span><br><span class="line">                dp.get(i).add(dpValue);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        int minValue&#x3D;0xfffffff;</span><br><span class="line">        List&lt;Integer&gt;LowestLine&#x3D;dp.get(triangle.size()-1);</span><br><span class="line">        for (Integer integer : LowestLine)</span><br><span class="line">        &#123;</span><br><span class="line">            if (integer&lt;minValue)minValue&#x3D;integer;</span><br><span class="line">        &#125;</span><br><span class="line">        return minValue;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="70-爬楼梯"><a href="#70-爬楼梯" class="headerlink" title="70. 爬楼梯"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/climbing-stairs/">70. 爬楼梯</a></h4><p>难度简单1543</p>
<p>假设你正在爬楼梯。需要 <em>n</em> 阶你才能到达楼顶。</p>
<p>每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？</p>
<p><strong>注意：</strong>给定 <em>n</em> 是一个正整数。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入： 2</span><br><span class="line">输出： 2</span><br><span class="line">解释： 有两种方法可以爬到楼顶。</span><br><span class="line">1.  1 阶 + 1 阶</span><br><span class="line">2.  2 阶</span><br></pre></td></tr></table></figure>

<p><strong>解答:</strong></p>
<p>这个还是蛮经典的  一个  第n阶楼梯只能从第n-1和n-2楼梯爬上来   最后得到的是一个斐波那契数列</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">climbStairs</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (n&lt;<span class="number">3</span>)<span class="keyword">return</span> n;</span><br><span class="line">       <span class="keyword">int</span> []dp=<span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>];</span><br><span class="line">       dp[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">       dp[<span class="number">2</span>]=<span class="number">2</span>;</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i &lt;=n; i++)</span><br><span class="line">       &#123;</span><br><span class="line">           dp[i]=dp[i-<span class="number">1</span>]+dp[i-<span class="number">2</span>];</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> dp[n];</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h4 id="53-最大子序和"><a href="#53-最大子序和" class="headerlink" title="53. 最大子序和"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/maximum-subarray/">53. 最大子序和</a></h4><p>给定一个整数数组 <code>nums</code> ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。 </p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums &#x3D; [-2,1,-3,4,-1,2,1,-5,4]</span><br><span class="line">输出：6</span><br><span class="line">解释：连续子数组 [4,-1,2,1] 的和最大，为 6 。</span><br></pre></td></tr></table></figure>

<p><strong>解答：</strong></p>
<p><code>dp[i]</code>表示代表以第 <strong>i</strong>个数结尾的「连续子数组的最大和」</p>
<p>因为要的是最大值 所以需要中途维护一个变量 一直保存这个最大值  然后 到<strong>i</strong>这里的话  有两个选择 </p>
<ul>
<li>取 第i个数</li>
<li>不取</li>
</ul>
<p>只需要比较一下  取了第i个数 大  还是让  i单独成一个子数组更大</p>
<p><code>dp[i]</code>赋值为那个较大就可以了</p>
<h4 id="416-分割等和子集"><a href="#416-分割等和子集" class="headerlink" title="416. 分割等和子集"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/partition-equal-subset-sum/">416. 分割等和子集</a></h4><p>给定一个<strong>只包含正整数</strong>的<strong>非空</strong>数组。是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。</p>
<p><strong>注意:</strong></p>
<ol>
<li>每个数组中的元素不会超过 100</li>
<li>数组的大小不会超过 200</li>
</ol>
<p><strong>示例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入: [1, 5, 11, 5]</span><br><span class="line"></span><br><span class="line">输出: true</span><br><span class="line"></span><br><span class="line">解释: 数组可以分割成 [1, 5, 5] 和 [11].</span><br></pre></td></tr></table></figure>

<p><strong>解答：</strong></p>
<p>首先可以特判一下  如果数组的总和是奇数   返回false</p>
<p>然后考虑  题目的意思就是要找是不是存在子数组的和=sum/2</p>
<p>创建一个二维bool DP数组 数组的大小为<code>dp[数组长度][target+1]</code> <code>DP[i][j]</code> 表示从数组的<code>0-i</code>范围内 能否找到一组组合 使得他们的和 ==j    这个一组组合也包括空集</p>
<p>如此一来就可以得到状态转移方程了 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[i][j]=dp[i-<span class="number">1</span>][j]||dp[i-<span class="number">1</span>][j-nums[i]];</span><br></pre></td></tr></table></figure>

<p>表示  如果不选<code>nums[i]</code>和选了<code>nums[i]</code>的情况  当然了  这里明显需要考虑<code>j</code>和<code>nums  i</code>的大小关系,最后的答案就是这个了</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> dp[nums.length-<span class="number">1</span>][target];</span><br></pre></td></tr></table></figure>

<h4 id="322-零钱兑换"><a href="#322-零钱兑换" class="headerlink" title="322. 零钱兑换"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/coin-change/">322. 零钱兑换</a></h4><p>给定不同面额的硬币 <code>coins</code> 和一个总金额 <code>amount</code>。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回 <code>-1</code>。</p>
<p>你可以认为每种硬币的数量是无限的。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：coins = [1, 2, 5], amount = 11</span><br><span class="line">输出：3 </span><br><span class="line">解释：11 = 5 + 5 + 1</span><br></pre></td></tr></table></figure>

<p><strong>解答:</strong></p>
<p>这样考虑 如果<code>dp[i]</code>是凑成总价值为<code>i</code>的 最小硬币个数  那它必然是由<code>DP[i  减去 （某一种硬币的面值）]</code>加上某一种硬币得来的 所以我们只需要找到 这些</p>
<blockquote>
<p>DP[i  减去 （某一种硬币的面值）]</p>
</blockquote>
<p>中  最小的一个  +1 就得到了 <code>dp[i]</code>的值了</p>
<p>如这个表展示的这样</p>
<p><img src="https://image.duckflew.cn/img/blog_inner_image20210319204348.png" alt="image-20210319204346572"></p>
<p>代码如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">coinChange</span><span class="params">(<span class="keyword">int</span>[] coins, <span class="keyword">int</span> amount)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] dp=<span class="keyword">new</span> <span class="keyword">int</span>[amount+<span class="number">1</span>];</span><br><span class="line">    dp[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    Arrays.sort(coins);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; amount + <span class="number">1</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        dp[i]=Integer.MAX_VALUE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;amount+<span class="number">1</span> ; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; coins.length; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (i&lt;coins[j])<span class="keyword">break</span>;</span><br><span class="line">            dp[i]=Math.min(dp[i-coins[j]]+<span class="number">1</span>,dp[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;System.out.println(Arrays.toString(dp));</span><br><span class="line">    <span class="keyword">if</span> (dp[amount]!=Integer.MAX_VALUE)</span><br><span class="line">        <span class="keyword">return</span> dp[amount];</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="1155-掷骰子的N种方法"><a href="#1155-掷骰子的N种方法" class="headerlink" title="1155. 掷骰子的N种方法"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/number-of-dice-rolls-with-target-sum/">1155. 掷骰子的N种方法</a></h4><p>难度中等81</p>
<p>这里有 <code>d</code> 个一样的骰子，每个骰子上都有 <code>f</code> 个面，分别标号为 <code>1, 2, ..., f</code>。</p>
<p>我们约定：掷骰子的得到总点数为各骰子面朝上的数字的总和。</p>
<p>如果需要掷出的总点数为 <code>target</code>，请你计算出有多少种不同的组合情况（所有的组合情况总共有 <code>f^d</code> 种），<strong>模 <code>10^9 + 7</code></strong> 后返回。<strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：d &#x3D; 1, f &#x3D; 6, target &#x3D; 3</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure>

<p><strong>解答</strong></p>
<p>还是考虑一个二维的DP数组   <code>dp[d+1][target+1]</code> <code>dp[i][j]</code>的值表示  扔<code>i</code>个骰子的时候  点数为 <code>j</code>的方法数  跟硬币那个题一样考虑  骰子一共有f面  那么<code>dp[i][j]</code>就等于所有的<code>dp[i-1][j-（1-f 之间的一个值 这个值就是第i个骰子的点数)]</code>加起来</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numRollsToTarget</span><span class="params">(<span class="keyword">int</span> d, <span class="keyword">int</span> f, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[d + <span class="number">1</span>][target+<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; d + <span class="number">1</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt;=Math.min(target,f*i); j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (i==<span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (j&lt;=f)</span><br><span class="line">                    dp[i][j] = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> dp[i][j]=<span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= f; k++)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span> (j&gt;k)</span><br><span class="line">                        dp[i][j]=(dp[i][j]+dp[i-<span class="number">1</span>][j-k])%(<span class="number">1000000000</span> + <span class="number">7</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[d][target];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里有几个可以优化的点    j可以从i开始  因为骰子最少都有一点</p>
<p>j最大值为  <code>i*f</code>  也就是全部满点的情况  再往后就投不出来了  直接赋值为0</p>
<p>然后这里犯了个有点SB的错误  把题目里面给的**<code>10^9 + 7</code>**直接就抄到了代码里面   在代码里面这个表示的异或的意思</p>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/maximum-length-of-repeated-subarray/">718. 最长重复子数组</a></p>
<p>给两个整数数组 <code>A</code> 和 <code>B</code> ，返回两个数组中公共的、长度最长的子数组的长度。</p>
<p><strong>示例：</strong></p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">A: [1,2,3,2,1]</span><br><span class="line">B: [3,2,1,4,7]</span><br><span class="line">输出：3</span><br><span class="line">解释：</span><br><span class="line">长度最长的公共子数组是 [3, 2, 1] </span><br></pre></td></tr></table></figure>

<p><strong>解答</strong></p>
<p>这个题采用动态规划的方法</p>
<p>创建一个二维DP数组  dp[i][j] 值表示A数组中以A[i]结尾的子数组</p>
<p>和B数组中以B[j]结尾的子数组的 长度最长的公共子数组的长度是</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findLength</span><span class="params">(<span class="keyword">int</span>[] A, <span class="keyword">int</span>[] B)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> lenA=A.length;</span><br><span class="line">        <span class="keyword">int</span> lenB=B.length;</span><br><span class="line">        <span class="keyword">int</span>[][]dp=<span class="keyword">new</span> <span class="keyword">int</span>[lenA][lenB];</span><br><span class="line">        <span class="keyword">int</span> maxLength=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; lenA; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; lenB; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (i==<span class="number">0</span>&amp;&amp;j==<span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span> (A[<span class="number">0</span>]==B[<span class="number">0</span>])</span><br><span class="line">                    &#123;</span><br><span class="line">                        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">                        maxLength=dp[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (i==<span class="number">0</span>||j==<span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span> (A[i]==B[j])</span><br><span class="line">                    &#123;</span><br><span class="line">                        dp[i][j] = <span class="number">1</span>;</span><br><span class="line">                        maxLength=Math.max(dp[i][j],maxLength);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> dp[i][j]=<span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (A[i]==B[j])</span><br><span class="line">                &#123;</span><br><span class="line"></span><br><span class="line">                    dp[i][j] = dp[i-<span class="number">1</span>][j-<span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">if</span> (dp[i][j]&gt;maxLength)maxLength=dp[i][j];</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (A[i]!=B[j]) dp[i][j]=<span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//        for (int[] ints : dp)</span></span><br><span class="line"><span class="comment">//        &#123;</span></span><br><span class="line"><span class="comment">//            System.out.println(Arrays.toString(ints));</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"><span class="comment">//        System.out.println(dp[1][2]);</span></span><br><span class="line">        <span class="keyword">return</span> maxLength;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="718-最长重复子数组"><a href="#718-最长重复子数组" class="headerlink" title="718. 最长重复子数组"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/maximum-length-of-repeated-subarray/">718. 最长重复子数组</a></h4><p>难度中等395</p>
<p>给两个整数数组 <code>A</code> 和 <code>B</code> ，返回两个数组中公共的、长度最长的子数组的长度。</p>
<p><strong>示例：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">A: [1,2,3,2,1]</span><br><span class="line">B: [3,2,1,4,7]</span><br><span class="line">输出：3</span><br><span class="line">解释：</span><br><span class="line">长度最长的公共子数组是 [3, 2, 1] 。</span><br></pre></td></tr></table></figure>

<p><strong>解答</strong></p>
<p>考虑一个二维DP数组  <code>dp[i][j]</code>  表示以<code>A[i]</code>结束的子数组和以<code>B[J]</code>的所有子数组的最长的重复子数组的长度  </p>
<p>很容易看出状态转移方程   如下  </p>
<ul>
<li>当   <code>A[i]</code>==<code>B[J]</code>  <code>dp[i][j]</code>=<code>dp[i-1][j-1]</code>+1</li>
<li>否则   <code>dp[i][j]</code>=0；</li>
</ul>
<p>并且在中途维护一个最大值的<code>dp[i][j]</code>    为ans   也就是答案了</p>
<p>代码如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findLength</span><span class="params">(<span class="keyword">int</span>[] A, <span class="keyword">int</span>[] B)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> lenA=A.length;</span><br><span class="line">    <span class="keyword">int</span> lenB=B.length;</span><br><span class="line">    <span class="keyword">int</span>[][]dp=<span class="keyword">new</span> <span class="keyword">int</span>[lenA][lenB];</span><br><span class="line">    <span class="keyword">int</span> maxLength=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; lenA; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; lenB; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (A[i]==B[j])</span><br><span class="line">            &#123;</span><br><span class="line">                dp[i][j]=(i==<span class="number">0</span>||j==<span class="number">0</span>)?<span class="number">1</span>:dp[i-<span class="number">1</span>][j-<span class="number">1</span>]+<span class="number">1</span>;</span><br><span class="line">                maxLength=Math.max(maxLength,dp[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">                dp[i][j]=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxLength;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="300-最长递增子序列"><a href="#300-最长递增子序列" class="headerlink" title="300. 最长递增子序列"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/longest-increasing-subsequence/">300. 最长递增子序列</a></h4><p>难度中等1456</p>
<p>给你一个整数数组 <code>nums</code> ，找到其中最长严格递增子序列的长度。</p>
<p>子序列是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，<code>[3,6,2,7]</code> 是数组 <code>[0,3,1,6,2,2,7]</code> 的子序列。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums &#x3D; [10,9,2,5,3,7,101,18]</span><br><span class="line">输出：4</span><br></pre></td></tr></table></figure>

<p><strong>解答</strong></p>
<p>这里有一个小小的需要注意的地方就是题目求的是序列 而不是子数组 序列并不需要严格连续</p>
<p><code>dp[i]</code>表示到以i结尾的严格递增子序列的长度</p>
<p>如何求i+1的dp值呢 我们只需要把0-i的每一个dp值都检验一下 找到（在满足 <code>nums[j]</code> 小于<code>nums[i+1]</code>的情况下)  的dp的最大值  然后加上1 就是i+1的dp值了  当然也有可能在这个过程中完全没有找到  那么i+1的dp值也就是1了 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLIS</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> []dp=<span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">    dp[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.length; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> cur=<span class="number">0</span>;<span class="comment">//找出从0-i-1最大的dp值 并且要满足numsj&lt;numsi</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[j]&lt;nums[i])cur=Math.max(cur,dp[j]+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        dp[i]=cur==<span class="number">0</span>?<span class="number">1</span>:cur;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (dp[i]&gt;res)res=dp[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="5-最长回文子串"><a href="#5-最长回文子串" class="headerlink" title="5. 最长回文子串"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/longest-palindromic-substring/">5. 最长回文子串</a></h4><p>难度中等3388</p>
<p>给你一个字符串 <code>s</code>，找到 <code>s</code> 中最长的回文子串。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s &#x3D; &quot;babad&quot;</span><br><span class="line">输出：&quot;bab&quot;</span><br><span class="line">解释：&quot;aba&quot; 同样是符合题意的答案。</span><br></pre></td></tr></table></figure>

<p><strong>解答</strong></p>
<p>对于长度&gt;=3的子串  如果头和尾部字母相同并且  中间的那一部分也是个回文串 那么这个子串也是回文串   </p>
<p>所以很明显 <code>dp[i][j]</code>表示 从i 到j （包含j）的子串</p>
<p>转移方程:<code>dp[i][j]</code>=<code>dp[i][j]</code>&amp;&amp;(<code>char[i-1]</code>==<code>char[j+1]</code>)</p>
<p>边界条件: </p>
<ul>
<li>长度为1   肯定是回文串</li>
<li>长度为2    两个字母相同就是回文串</li>
</ul>
<p>由于题目要求的是最长的回文子串  可以维护一个最长的子串的坐标   在所有的DP都求完 了之后   再切割字符串然后返回</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">longestPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span>[][] dp=<span class="keyword">new</span> <span class="keyword">boolean</span>[s.length()][s.length()  ];</span><br><span class="line">    <span class="keyword">int</span> maxi=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> maxj=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = s.length()-<span class="number">1</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">char</span> chi=s.charAt(i);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; s.length(); j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">char</span> chj=s.charAt(j);</span><br><span class="line">            <span class="keyword">if</span> (j==i)dp[i][j]=<span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (j-i&lt;<span class="number">3</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                dp[i][j] = chi == chj;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> dp[i][j]=(chi==chj)&amp;&amp;(dp[i+<span class="number">1</span>][j-<span class="number">1</span>]);</span><br><span class="line">            <span class="keyword">if</span> (dp[i][j]&amp;&amp;(j-i)&gt;(maxj-maxi))</span><br><span class="line">            &#123;</span><br><span class="line">                maxi=i;</span><br><span class="line">                maxj=j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s.substring(maxi,maxj+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="678-有效的括号字符串"><a href="#678-有效的括号字符串" class="headerlink" title="678. 有效的括号字符串"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/valid-parenthesis-string/">678. 有效的括号字符串</a></h4><p>难度中等216</p>
<p>给定一个只包含三种字符的字符串：<code>（ </code>，<code>）</code> 和 <code>*</code>，写一个函数来检验这个字符串是否为有效字符串。有效字符串具有如下规则：</p>
<ol>
<li>任何左括号 <code>(</code> 必须有相应的右括号 <code>)</code>。</li>
<li>任何右括号 <code>)</code> 必须有相应的左括号 <code>(</code> 。</li>
<li>左括号 <code>(</code> 必须在对应的右括号之前 <code>)</code>。</li>
<li><code>*</code> 可以被视为单个右括号 <code>)</code> ，或单个左括号 <code>(</code> ，或一个空字符串。</li>
<li>一个空字符串也被视为有效字符串。</li>
</ol>
<p><strong>示例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;()&quot;</span><br><span class="line">输出: True</span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;(*)&quot;</span><br><span class="line">输出: True</span><br></pre></td></tr></table></figure>

<p><strong>示例 3:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;(*))&quot;</span><br><span class="line">输出: True</span><br></pre></td></tr></table></figure>

<p><strong>解答</strong></p>
<p>这个题还是DP问题  但是我用的是暴力的方法    思路如下</p>
<p>设置两个栈   一个栈来保存左括号的位置  一个栈用来存星星的位子</p>
<p>如果遇到右括号  就先让左括号和它匹配    因为按照贪心的思想   星星是可以作为空字符串的   但是左括号必须要被匹配掉  因此优先匹配左括号  如果 左括号的栈不为空  就弹出 如果为空  就检查星星栈</p>
<p>星星栈也为空就返回false 不为空就弹出  这里就是把星星当做左括号在用   最后循环结束之后如果还没有返回  说明所有的右括号都找到匹配的了  那就检查左括号栈  让星星和左括号去消除匹配 但是这里有个问题就是星星的位置必须在左括号的后面  也就是<code>starStack.peek &gt; leftStack.peek </code></p>
<p>如果不能满足  亦或是starStack已经为空了而  leftStack还没有空  也返回false  </p>
<p>最后leftStack也空了  就返回true了  代码如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">checkValidString</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span>[] chars = s.toCharArray();</span><br><span class="line">    Stack&lt;Integer&gt; leftStack=<span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    Stack&lt;Integer&gt; starStack=<span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; chars.length; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">char</span> cur=chars[i];</span><br><span class="line">        <span class="keyword">if</span> (cur==<span class="string">&#x27;(&#x27;</span>)</span><br><span class="line">            leftStack.push(i);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (cur==<span class="string">&#x27;*&#x27;</span>)</span><br><span class="line">            starStack.push(i);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (!leftStack.isEmpty())leftStack.pop();</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (!starStack.isEmpty())</span><br><span class="line">                    starStack.pop();</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (leftStack.size()&gt;starStack.size())<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">while</span> (!leftStack.isEmpty())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (starStack.peek()&gt;leftStack.peek())</span><br><span class="line">        &#123;</span><br><span class="line">            starStack.pop();</span><br><span class="line">            leftStack.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="https://129duckflew.github.io/2021/03/21/LeetCode%20%E7%AC%94%E8%AE%B0----DP%E9%97%AE%E9%A2%98/" data-id="ckmjbdb9f000em4vectb74kg8" data-title="LeetCode 笔记----DP问题" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-LeetCode 笔记--- 二叉树" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/03/21/LeetCode%20%E7%AC%94%E8%AE%B0---%20%E4%BA%8C%E5%8F%89%E6%A0%91/" class="article-date">
  <time class="dt-published" datetime="2021-03-21T15:31:56.818Z" itemprop="datePublished">2021-03-21</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/03/21/LeetCode%20%E7%AC%94%E8%AE%B0---%20%E4%BA%8C%E5%8F%89%E6%A0%91/">LeetCode 笔记--- 二叉树</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="LeetCode-笔记—-二叉树"><a href="#LeetCode-笔记—-二叉树" class="headerlink" title="LeetCode 笔记— 二叉树"></a>LeetCode 笔记— 二叉树</h1><h3 id="501-求BST的众数"><a href="#501-求BST的众数" class="headerlink" title="501.求BST的众数"></a>501.求BST的众数</h3><p>这个题不需要另外定义一个map  会造成空间的浪费 因为根据BST的特性  中序遍历  相同的元素都是排在一起的 所以只需要维护一个maxNum curNum cur<br>遍历到不同的元素  就刷新cur curnum复位为1  并且和Maxnum比较  如果相同  就加入到结果数组  如果不相同  就把结果数组清空  再加入</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> cur;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">int</span> curNum;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">int</span> maxNum=-<span class="number">1</span>;</span><br><span class="line">   <span class="keyword">private</span> List&lt;Integer&gt;res;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">int</span>[] findMode(TreeNode root) &#123;</span><br><span class="line">       res=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">       dfs(root);</span><br><span class="line">       <span class="keyword">int</span> []ans=<span class="keyword">new</span> <span class="keyword">int</span>[res.size()];</span><br><span class="line">       <span class="keyword">if</span> (res.size()&gt;<span class="number">0</span>)</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ans.length; i++)</span><br><span class="line">       &#123;</span><br><span class="line">           ans[i]=res.get(i);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> ans;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode root)</span></span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (root==<span class="keyword">null</span>)<span class="keyword">return</span> ;</span><br><span class="line">       dfs(root.left);</span><br><span class="line">       update(root.val);</span><br><span class="line">       dfs(root.right);</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (val!=cur)</span><br><span class="line">       &#123;</span><br><span class="line">           cur=val;</span><br><span class="line">           curNum=<span class="number">1</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">else</span></span><br><span class="line">       &#123;</span><br><span class="line">           curNum++;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span> (curNum&gt;maxNum)</span><br><span class="line">       &#123;</span><br><span class="line">           res.clear();</span><br><span class="line">           res.add(cur);</span><br><span class="line">           maxNum=curNum;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">else</span> <span class="keyword">if</span> (curNum&lt;maxNum)</span><br><span class="line">       &#123;</span><br><span class="line"></span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">else</span></span><br><span class="line">       &#123;</span><br><span class="line">           res.add(cur);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h3 id="109-有序链表转化为BST"><a href="#109-有序链表转化为BST" class="headerlink" title="109.有序链表转化为BST"></a>109.有序链表转化为BST</h3><p>给定的有序链表： [-10, -3, 0, 5, 9],<br>一个可能的答案是：[0, -3, 9, -10, null, 5], 它可以表示下面这个高度平衡二叉搜索树：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">     0</span><br><span class="line">    &#x2F; \</span><br><span class="line">  -3   9</span><br><span class="line">  &#x2F;   &#x2F;</span><br><span class="line">-10  5</span><br></pre></td></tr></table></figure>

<p>快慢指针加分治法<br>首先求出链表的中间节点作为树的根节点  然后以Mid节点为界 对左右两个链表采取同样的方法 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span>   TreeNode <span class="title">sortedListToBST</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> buildTree(head,<span class="keyword">null</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span>  TreeNode <span class="title">buildTree</span><span class="params">(ListNode left,ListNode right)</span></span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (left==right)<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">       ListNode mid = findMidListNode(left, right);</span><br><span class="line">       TreeNode newNode = <span class="keyword">new</span> TreeNode(mid.val);</span><br><span class="line">       newNode.left=buildTree(left,mid);</span><br><span class="line">       newNode.right=buildTree(mid.next,right);</span><br><span class="line">       <span class="keyword">return</span> newNode;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span>  ListNode <span class="title">findMidListNode</span><span class="params">(ListNode left,ListNode right)</span></span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (left==right)<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">       ListNode slow=left;</span><br><span class="line">       ListNode fast=left;</span><br><span class="line">       <span class="keyword">while</span> (fast!=right&amp;&amp;fast.next!=right)</span><br><span class="line">       &#123;</span><br><span class="line">           slow=slow.next;</span><br><span class="line">           fast=fast.next;</span><br><span class="line">           fast=fast.next;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> slow;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="538-把二叉搜索树转化为累加树"><a href="#538-把二叉搜索树转化为累加树" class="headerlink" title="538.把二叉搜索树转化为累加树"></a>538.把二叉搜索树转化为累加树</h3><p>要把一个BST转化为每个节点值变成大于等于原节点元素的树  只需要倒序遍历 维护一个sum变量  到哪个点了就root.val=root.val+sum<br>tips 这里的倒序不是说的后序遍历 而是说 逆中序遍历 即为先遍历right子树</p>
<h3 id="230-求二叉搜索树的第K个最小的元素"><a href="#230-求二叉搜索树的第K个最小的元素" class="headerlink" title="230.求二叉搜索树的第K个最小的元素"></a>230.求二叉搜索树的第K个最小的元素</h3><p>这个题就是中序遍历 然后用一个hasReadNum作为标志表示当前你已经遍历到第几个元素了  如果是第k个  返回就是了  如果大于 直接返回 相当于剪枝</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> hasReadNum;</span><br><span class="line">   <span class="keyword">int</span> res;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">kthSmallest</span><span class="params">(TreeNode root, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        res=<span class="number">0</span>;</span><br><span class="line">       hasReadNum=<span class="number">0</span>;</span><br><span class="line">       dfs(root,k);</span><br><span class="line">       <span class="keyword">return</span> res;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode root,<span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (root==<span class="keyword">null</span>)<span class="keyword">return</span> ;</span><br><span class="line">       dfs(root.left,k);</span><br><span class="line">       hasReadNum++;</span><br><span class="line">       <span class="keyword">if</span> (hasReadNum==k)</span><br><span class="line">       &#123;</span><br><span class="line">           res=root.val;</span><br><span class="line">           <span class="keyword">return</span> ;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">else</span> <span class="keyword">if</span> (hasReadNum&gt;k)</span><br><span class="line">       &#123;</span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       dfs(root.right,k);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h3 id="669-修剪二叉搜索树"><a href="#669-修剪二叉搜索树" class="headerlink" title="669.修剪二叉搜索树"></a>669.修剪二叉搜索树</h3><blockquote>
<p>给你二叉搜索树的根节点 root ，同时给定最小边界low 和最大边界 high。通过修剪二叉搜索树，使得所有节点的值在[low, high]中。修剪树不应该改变保留在树中的元素的相对结构（即，如果没有被移除，原有的父代子代关系都应当保留）。 可以证明，存在唯一的答案。<br>所以结果应当返回修剪好的二叉搜索树的新的根节点。注意，根节点可能会根据给定的边界发生改变。<br><img src="https://assets.leetcode.com/uploads/2020/09/09/trim2.jpg"><br>思路: 假设trimBST的结果是理想的 判断一下我当前节点 的值 如果root.val&lt;l说明只需要考虑右子树  左子树已经不符合了  这是搜索树的性质  同理 如果root.val&gt;R 那只需要判断左子树</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">trimBST</span><span class="params">(TreeNode root, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (root==<span class="keyword">null</span>)<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">       <span class="keyword">if</span> (root.val&gt;high)<span class="keyword">return</span> trimBST(root.left,low,high);</span><br><span class="line">       <span class="keyword">if</span> (root.val&lt;low)<span class="keyword">return</span> trimBST(root.right,low,high);</span><br><span class="line">       root.left=trimBST(root.left,low,high);</span><br><span class="line">       root.right=trimBST(root.right,low,high);</span><br><span class="line">       <span class="keyword">return</span> root;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h3 id="637-二叉树的层平均值"><a href="#637-二叉树的层平均值" class="headerlink" title="637.二叉树的层平均值"></a>637.二叉树的层平均值</h3><p>BFS遍历每一层 需要注意的是 每一次Poll元素之前先记录一下此时的queue有多少个元素 这个个数就是本层有多少个元素 sum就+  这么多次  然后sum/num 就是本层平均值了  在循环内部其实还是正常的BFS该添加元素就元素 因为队列的特性是可以记录的每一层的  513题的找最后一层最左边的元素也是这个方法  判断i==0 也就是每一层的第一个元素的时候 就更新一次答案就行了</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span>  List&lt;Double&gt; <span class="title">averageOfLevels</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (root==<span class="keyword">null</span>)<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">       List&lt;Double&gt;averages=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">       Queue&lt;TreeNode&gt;queue=<span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">       queue.add(root);</span><br><span class="line">       <span class="keyword">while</span> (!queue.isEmpty())</span><br><span class="line">       &#123;</span><br><span class="line">           <span class="keyword">long</span> levelSum=<span class="number">0</span>;</span><br><span class="line">           <span class="keyword">int</span> levelNum=queue.size();</span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; levelNum; i++)</span><br><span class="line">           &#123;</span><br><span class="line">               TreeNode top = queue.poll();</span><br><span class="line">               levelSum+=top.val;</span><br><span class="line">               <span class="keyword">if</span> (top.left!=<span class="keyword">null</span>)queue.add(top.left);</span><br><span class="line">               <span class="keyword">if</span> (top.right!=<span class="keyword">null</span>)queue.add(top.right);</span><br><span class="line">           &#125;</span><br><span class="line">           averages.add(levelSum/(levelNum*<span class="number">1.0</span>));</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> averages;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h3 id="687-最长同值路径"><a href="#687-最长同值路径" class="headerlink" title="687.最长同值路径"></a>687.最长同值路径</h3><blockquote>
<p>给定一个二叉树，找到最长的路径，这个路径中的每个节点具有相同值。 这条路径可以经过也可以不经过根节点。<br>注意：两个节点之间的路径长度由它们之间的边数表示</p>
</blockquote>
<p>也是找2个节点之间的一条路径 这条路径上的所有的节点的值都是相同的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> max=Integer.MIN_VALUE;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestUnivaluePath</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (root==<span class="keyword">null</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">       postOrder(root);</span><br><span class="line">       <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">postOrder</span><span class="params">(TreeNode root)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root==<span class="keyword">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> leftArrow=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> rightArrow=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> leftValue=postOrder(root.left);</span><br><span class="line">        <span class="keyword">int</span> rightValue=postOrder(root.right);</span><br><span class="line">        <span class="keyword">if</span> (root.left!=<span class="keyword">null</span>&amp;&amp;root.left.val==root.val)</span><br><span class="line">        &#123;</span><br><span class="line">            leftArrow=(leftValue+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (root.right!=<span class="keyword">null</span>&amp;&amp;root.right.val==root.val)</span><br><span class="line">        &#123;</span><br><span class="line">            rightArrow=(rightValue+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        max=Math.max(max,leftArrow+rightArrow);</span><br><span class="line">        <span class="keyword">return</span> Math.max(leftArrow,rightArrow);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>这个题和以前的求最长的路径有点像<br>递归回溯每个节点 返回的都是这个节点上  左右单支能够取到的最长路径的长度<br>如果我本节点的值和我的左子树的最长同值路径相等 那就让leftArrow=leftValue+1 也就是得到了现在的左边的最长的同值路径 同理可以得到最长的右边的同值路径  leftArrow 把这俩加起来  同max做比较  更新max的值 最后对于这个节点 返回的还是leftarrow 和rightarrow中较大的那个 因为只能取单边路径</p>
<h3 id="404-左叶子之和"><a href="#404-左叶子之和" class="headerlink" title="404.左叶子之和"></a>404.左叶子之和</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> sum;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sumOfLeftLeaves</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        sum=<span class="number">0</span>;</span><br><span class="line">        fun(root,<span class="keyword">false</span>);</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fun</span><span class="params">(TreeNode root,<span class="keyword">boolean</span> isLeft)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root==<span class="keyword">null</span>)<span class="keyword">return</span> ;</span><br><span class="line">        <span class="keyword">if</span> (isLeft&amp;&amp;root.left==<span class="keyword">null</span>&amp;&amp;root.right==<span class="keyword">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            sum+=root.val;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        fun(root.left,<span class="keyword">true</span>);</span><br><span class="line">        fun(root.right,<span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="101-对称二叉树"><a href="#101-对称二叉树" class="headerlink" title="101.对称二叉树"></a>101.对称二叉树</h3><p>给定一个二叉树，检查它是否是镜像对称的。<br>例如，二叉树 [1,2,2,3,4,4,3] 是对称的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    1</span><br><span class="line">   &#x2F; \</span><br><span class="line">  2   2</span><br><span class="line"> &#x2F; \ &#x2F; \</span><br><span class="line">3  4 4  3</span><br></pre></td></tr></table></figure>

<p>一棵树满足镜像对称  就是说他的两个子树需要镜像对称<br>两颗树需要镜像对称  条件有三个</p>
<ul>
<li>根节点的值相等</li>
<li>a树的左子树与b树的右子树镜像对称</li>
<li>a树的右子树与b树的左子树镜像对称</li>
</ul>
<p>如此一来就可以写成递归的形式了</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public boolean isSymmetric(TreeNode root) &#123;</span><br><span class="line">       if (root&#x3D;&#x3D;null)return true;</span><br><span class="line">       return twoTreeIsMirroring(root.left,root.right);</span><br><span class="line">   &#125;</span><br><span class="line">   public boolean twoTreeIsMirroring(TreeNode t1,TreeNode t2)</span><br><span class="line">   &#123;</span><br><span class="line">       if (t1&#x3D;&#x3D;null&amp;&amp;t2&#x3D;&#x3D;null)return true;</span><br><span class="line">       if (t1&#x3D;&#x3D;null||t2&#x3D;&#x3D;null)return false;</span><br><span class="line">       return t1.val&#x3D;&#x3D;t2.val&amp;&amp;twoTreeIsMirroring(t1.left, t2.right)&amp;&amp;twoTreeIsMirroring(t1.right,t2.left);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h3 id="572-另一个树的子树"><a href="#572-另一个树的子树" class="headerlink" title="572.另一个树的子树"></a>572.另一个树的子树</h3><p>暴力解法写了  还没写更好的算法测试<br>暴力法如下<br>遍历第一棵树的每个节点依次判断这个节点为root的子树是否与另外一颗树相等<br>treeEquals就是判断相等的方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSubtree</span><span class="params">(TreeNode s, TreeNode t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (t==<span class="keyword">null</span>)<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 如果t等于null 那么t就是任何树的子树  因为 任何一棵树都有null节点</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (s==<span class="keyword">null</span>)<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 如果s==null 那么s不可能有子树 除非t也等于null 但是这种情况在前面已经是判断了的</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">return</span> treeEquals(s, t)||isSubtree(s.left,t)||isSubtree(s.right,t);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断树是否相等的递归函数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> t1</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> t2</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">treeEquals</span><span class="params">(TreeNode t1,TreeNode t2)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (t1==<span class="keyword">null</span>)<span class="keyword">return</span> t2==<span class="keyword">null</span>;  <span class="comment">//同时为null 相等</span></span><br><span class="line">        <span class="keyword">if</span> (t2==<span class="keyword">null</span>)<span class="keyword">return</span> <span class="keyword">false</span>;  <span class="comment">//后面的为Null  就不相等</span></span><br><span class="line">        <span class="keyword">if</span> (t1.val!=t2.val)<span class="keyword">return</span> <span class="keyword">false</span>;  <span class="comment">//两个根节点的值不相等那就是两棵树不相等</span></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 然后递归 左子树和柚子树  只有左右子树同时相等 树才能相等</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">return</span> treeEquals(t1.left,t2.left)&amp;&amp;treeEquals(t1.right,t2.right);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="112-路径总和"><a href="#112-路径总和" class="headerlink" title="112.路径总和"></a>112.路径总和</h3><blockquote>
<p>给定一个二叉树和一个目标和，判断该树中是否存在根节点到叶子节点的路径，这条路径上所有节点值相加等于目标和。<br>说明: 叶子节点是指没有子节点的节点。<br>示例:<br>给定如下二叉树，以及目标和 sum = 22，</p>
</blockquote>
<pre><code>          5
         / \
        4   8
       /   / \
      11  13  4
     /  \      \
    7    2      1
</code></pre>
<blockquote>
<p>返回 true, 因为存在目标和为 22 的根节点到叶子节点的路径 5-&gt;4-&gt;11-&gt;2。</p>
</blockquote>
<p>这个题符合递归的思想 要找树的路径上的节点值之和是否等于某个值sum  换个角度来说  就是找 左右子树有的路径上的节点之和是否等于某个sum-root.val<br>递归终点就是  如果当前是叶子节点了 就判断当前的root.val是否等于sum</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasPathSum</span><span class="params">(TreeNode root, <span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root==<span class="keyword">null</span>)<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (root.left==<span class="keyword">null</span>&amp;&amp;root.right==<span class="keyword">null</span>)<span class="keyword">return</span> sum==root.val;</span><br><span class="line">        <span class="keyword">return</span> (hasPathSum(root.left,sum-root.val)||hasPathSum(root.right,sum-root.val));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>非递归写法 利用广度优先遍历 把每个节点到root节点的节点值之和存起来 两个队列里面11对应 遍历到叶子节点就判断一下  如果满足条件就返回<br>如果遍历完了都没返回 说明不存在 就返回 false</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasPathSum</span><span class="params">(TreeNode root, <span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root==<span class="keyword">null</span>)<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        Queue&lt;TreeNode&gt; nodeQueue=<span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">        Queue&lt;Integer&gt;pathQueue=<span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">        nodeQueue.add(root);</span><br><span class="line">        pathQueue.add(root.val);</span><br><span class="line">        <span class="keyword">while</span> (!nodeQueue.isEmpty())</span><br><span class="line">        &#123;</span><br><span class="line">            TreeNode cur=nodeQueue.poll();</span><br><span class="line">            <span class="keyword">int</span> curSum=pathQueue.poll();</span><br><span class="line">            <span class="keyword">if</span> (cur.left==<span class="keyword">null</span>&amp;&amp;cur.right==<span class="keyword">null</span>&amp;&amp;curSum==sum)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">if</span>  (cur.left!=<span class="keyword">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                nodeQueue.add(cur.left);</span><br><span class="line">                pathQueue.add(curSum+cur.left.val);</span><br><span class="line">            &#125;</span><br><span class="line">             <span class="keyword">if</span>  (cur.right!=<span class="keyword">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                nodeQueue.add(cur.right);</span><br><span class="line">                pathQueue.add(curSum+cur.right.val);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="617-合并二叉树"><a href="#617-合并二叉树" class="headerlink" title="617.合并二叉树"></a>617.合并二叉树</h3><p>给定两个二叉树，想象当你将它们中的一个覆盖到另一个上时，两个二叉树的一些节点便会重叠。</p>
<p>你需要将他们合并为一个新的二叉树。合并的规则是如果两个节点重叠，那么将他们的值相加作为节点合并后的新值，否则不为 NULL 的节点将直接作为新二叉树的节点。</p>
<blockquote>
<p>示例 1:<br>输入:<br>Tree 1                     Tree 2<br>1                         2<br>/ \                       / \<br>3   2                     1   3<br>/                           \   \<br>5                             4   7<br>输出:<br>合并后的树:<br>3<br>/ <br>4   5<br>/ \   \<br>5   4   7</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">mergeTrees</span><span class="params">(TreeNode t1, TreeNode t2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (t1==<span class="keyword">null</span>&amp;&amp;t2==<span class="keyword">null</span>)<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (t1==<span class="keyword">null</span>)<span class="keyword">return</span> t2;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (t2==<span class="keyword">null</span>)<span class="keyword">return</span> t1;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">        &#123;</span><br><span class="line">            TreeNode newNode = <span class="keyword">new</span> TreeNode(t1.val + t2.val);</span><br><span class="line">            newNode.left=mergeTrees(t1.left,t2.left);</span><br><span class="line">            newNode.right=mergeTrees(t1.right,t2.right);</span><br><span class="line">            <span class="keyword">return</span> newNode;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="226-翻转二叉树"><a href="#226-翻转二叉树" class="headerlink" title="226.翻转二叉树"></a>226.翻转二叉树</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">invertTree</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        invertTreeNode(root);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">invertTreeNode</span><span class="params">(TreeNode root)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root==<span class="keyword">null</span>)<span class="keyword">return</span> ;</span><br><span class="line">        invertTree(root.left);</span><br><span class="line">        invertTree(root.right);</span><br><span class="line">        TreeNode temp=root.left;</span><br><span class="line">        root.left=root.right;</span><br><span class="line">        root.right=temp;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>谷歌：我们90％的工程师使用您编写的软件(Homebrew)，但是您却无法在面试时在白板上写出翻转二叉树这道题，这太糟糕了。</p>
</blockquote>
<p>刷完这个题说明我已经超越了世界级大牛了</p>
<h3 id="543-二叉树的直径"><a href="#543-二叉树的直径" class="headerlink" title="543.二叉树的直径"></a>543.二叉树的直径</h3><p>二叉树的直径定义为任意两个节点之间的距离的最大值<br>做法就是递归二叉树  返回左右子树种  单支的长度的较大值+1  就是本节点开始的单支的长度  然后维护一个max值 每次遍历到节点就更新一次max的值  max与left单支的长度+right单支的长度+1 比较  取较大值   其实这个题可以看成是  找所有的节点中左右字数高度和最长的那个节点<br>代码如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> max;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">diameterOfBinaryTree</span><span class="params">(TreeNode root)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root==<span class="keyword">null</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        maxDanZhi(root);</span><br><span class="line">        <span class="keyword">return</span> max-<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxDanZhi</span><span class="params">(TreeNode root)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root==<span class="keyword">null</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> left=maxDanZhi(root.left);</span><br><span class="line">        <span class="keyword">int</span> right=maxDanZhi(root.right);</span><br><span class="line">        max=Math.max(max,left+right+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> Math.max(left,right)+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="110-判断一棵二叉树是否是平衡二叉树"><a href="#110-判断一棵二叉树是否是平衡二叉树" class="headerlink" title="110.判断一棵二叉树是否是平衡二叉树"></a>110.判断一棵二叉树是否是平衡二叉树</h3><p>最优的方法是采用后序遍历 统计左右子树的深度  如果左右子树的深度有一个是-1 说明在子树里面有已经有节点不满足平衡二叉树的定义了  那这棵树也返回-1就可以了  如果  两个深度都不是-1  那就判断他们的差是不是0或者1,如果不是 又不满足 还是返回-1  满足的话  则求出本树的深度 即为max(左子树的深度,右子树的深度)+1;</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">postOrder</span><span class="params">(TreeNode root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root==<span class="keyword">null</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> leftDepth=postOrder(root.left);</span><br><span class="line">    <span class="keyword">if</span> (leftDepth==-<span class="number">1</span>)<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> rightDepth=postOrder(root.right);</span><br><span class="line">    <span class="keyword">if</span> (rightDepth==-<span class="number">1</span>)<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> Math.abs(leftDepth-rightDepth)&lt;<span class="number">2</span>?Math.max(leftDepth,rightDepth)+<span class="number">1</span>:-<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isBalanced</span><span class="params">(TreeNode root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> postOrder(root)!=-<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="104-二叉树的最大深度"><a href="#104-二叉树的最大深度" class="headerlink" title="104.二叉树的最大深度"></a>104.二叉树的最大深度</h3><blockquote>
<p>二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。</p>
</blockquote>
<p>二叉树的深度=max(左子树的深度右子树的深度)+1</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (root==<span class="keyword">null</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">return</span> Integer.max(maxDepth(root.left),maxDepth(root.right))+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id=""><a href="#" class="headerlink" title=""></a></h3>
      
    </div>
    <footer class="article-footer">
      <a data-url="https://129duckflew.github.io/2021/03/21/LeetCode%20%E7%AC%94%E8%AE%B0---%20%E4%BA%8C%E5%8F%89%E6%A0%91/" data-id="ckmjbdb9f000fm4vefmcn0dv7" data-title="LeetCode 笔记--- 二叉树" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-DmitriRender30天试用到期后无限试用方法" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/03/21/DmitriRender30%E5%A4%A9%E8%AF%95%E7%94%A8%E5%88%B0%E6%9C%9F%E5%90%8E%E6%97%A0%E9%99%90%E8%AF%95%E7%94%A8%E6%96%B9%E6%B3%95/" class="article-date">
  <time class="dt-published" datetime="2021-03-21T15:31:56.816Z" itemprop="datePublished">2021-03-21</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/03/21/DmitriRender30%E5%A4%A9%E8%AF%95%E7%94%A8%E5%88%B0%E6%9C%9F%E5%90%8E%E6%97%A0%E9%99%90%E8%AF%95%E7%94%A8%E6%96%B9%E6%B3%95/">DmitriRender30天试用到期后无限试用方法</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="DmitriRender30天试用到期后无限试用方法"><a href="#DmitriRender30天试用到期后无限试用方法" class="headerlink" title="DmitriRender30天试用到期后无限试用方法"></a>DmitriRender30天试用到期后无限试用方法</h1><p>Win+R输入【regedit】启动注册表编辑器</p>
<p>找到【HKEY_CURRENT_USER\Software\】下的【DmitriRender】文件夹右键删除</p>
<p>打开【我的文档】关掉系统文件保护并显示隐藏文件</p>
<p>打开【desktop.ini】删除【IconIndex=-235】下面的所有内容并保存（不包含IconIndex=-235）</p>
<p>回到步骤2.2.2重新激活程序</p>
<p>到下一个30天后重复此步骤达到无限试用的目的</p>
<p><img src="https://image.duckflew.cn/img/blog_inner_image20201113204244.png" alt="img"></p>
<p><img src="https://image.duckflew.cn/img/blog_inner_image20201113204247.png" alt="img"></p>
<p><img src="https://image.duckflew.cn/img/blog_inner_image20201113204249.png" alt="img"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://129duckflew.github.io/2021/03/21/DmitriRender30%E5%A4%A9%E8%AF%95%E7%94%A8%E5%88%B0%E6%9C%9F%E5%90%8E%E6%97%A0%E9%99%90%E8%AF%95%E7%94%A8%E6%96%B9%E6%B3%95/" data-id="ckmjbdb8z0001m4ve8ciz88qz" data-title="DmitriRender30天试用到期后无限试用方法" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-Clion安装与配置" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/03/21/Clion%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE/" class="article-date">
  <time class="dt-published" datetime="2021-03-21T15:31:56.793Z" itemprop="datePublished">2021-03-21</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/03/21/Clion%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE/">Clion安装与配置</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>既然HRH一大早都来催我了 那我怎么能不快点更呢  这就是爱啊</p>
<p>老哥们 都大二了丢掉你的DEV cb吧 新环境只有安装时候是痛苦的，用的时候那是真快乐</p>
<p>居然还有小伙伴屡次因为CB不会改设置导致各种问题来问我我只能说 换编译器吧<br>结果发现VS2019又不会装？</p>
<p>所以 我今天就来出个 Clion安装及配置 （狗头）</p>
<p>（那我为啥要提VS呢 我也不知道可能是因为爱吧）</p>
<p>首先声明一点,Clion是jetbrains公司的产品 大部分产品都是要收费的 Clion就是<br>所以下面我介绍的是破解版 建议有能力的同学使用正版 支持正版从你我做起。</p>
<p>进入正题</p>
<h2 id="1-MINGW64-的下载-安装"><a href="#1-MINGW64-的下载-安装" class="headerlink" title="1.  MINGW64 的下载 安装"></a>1.  MINGW64 的下载 安装</h2><p>  （这里注意 如果你的电脑上安装了DEV<br>   并且你确认自己能够找到它的安装目录下的MINGW64文件夹 你可以直接跳过这一步）</p>
<p>   考虑到在线安装速度实在感人 我已经放弃 提前给你们下载好了 链接我放在这里<br>   MINGW64: <a target="_blank" rel="noopener" href="https://www.90pan.com/b2051500"> 点击下载文件 </a><br>密码：syw2<br>   如果出现无法解压的情况建议换个压缩软件 推荐bandizip</p>
<p>   安装直接解压即可 注意一个小问题 尽量不要放在中文路径下</p>
<p>   最好就是放在D:/program files/下就行或者D:/program files(x86)<br>   前面哪个盘符不重要主要是不要有中文</p>
<h2 id="2-mingw64的环境变量配置"><a href="#2-mingw64的环境变量配置" class="headerlink" title="2.mingw64的环境变量配置"></a>2.mingw64的环境变量配置</h2><h3 id="windows键-就是你键盘上那个印着windows标志的那个键-一般在ctrl-和alt中间-搜索-环境变量"><a href="#windows键-就是你键盘上那个印着windows标志的那个键-一般在ctrl-和alt中间-搜索-环境变量" class="headerlink" title="windows键(就是你键盘上那个印着windows标志的那个键 一般在ctrl 和alt中间)搜索  环境变量"></a>windows键(就是你键盘上那个印着windows标志的那个键 一般在ctrl 和alt中间)搜索  环境变量</h3><img src="https://image.duckflew.cn/img/blog_inner_image20201101171331.png" alt="image-20200809181909207" style="zoom: 33%;" />

<img src="https://image.duckflew.cn/img/blog_inner_image20201101171334.png" alt="image-20200809183139409" style="zoom: 33%;" />



<h3 id="双击path"><a href="#双击path" class="headerlink" title="双击path"></a>双击path</h3><img src="https://image.duckflew.cn/img/blog_inner_image20201101171338.png" alt="image-20200809183418096" style="zoom:50%;" />

<img src="https://image.duckflew.cn/img/blog_inner_image20201101171340.png" alt="image-20200809183323079" style="zoom:50%;" />

<h3 id="添加这一条就可以了-这个路径就是你mingw64的解压路径-根据你安装的位置灵活选择"><a href="#添加这一条就可以了-这个路径就是你mingw64的解压路径-根据你安装的位置灵活选择" class="headerlink" title="添加这一条就可以了  这个路径就是你mingw64的解压路径  根据你安装的位置灵活选择"></a>添加这一条就可以了  这个路径就是你mingw64的解压路径  根据你安装的位置灵活选择</h3><p><img src="https://image.duckflew.cn/img/blog_inner_image20201101171342.png" alt="image-20200809183520034"></p>
<h2 id="3-Clion-下载"><a href="#3-Clion-下载" class="headerlink" title="3.  Clion 下载"></a>3.  Clion 下载</h2><p>   由于安装包有点大这里我就没办法上传了 没办法在我的博客里面下载<br>   (虽然github支持上传大文件 但是我懒得折腾 基槽基槽)</p>
<p>   放个百度云链接吧</p>
<p>   链接：<a target="_blank" rel="noopener" href="https://pan.baidu.com/s/1dJHZwhnjq3UDI5WiLE-nDQ">https://pan.baidu.com/s/1dJHZwhnjq3UDI5WiLE-nDQ</a><br>   提取码：dftt<br>   觉得百度云速度慢可以手动搜索 clion历史版本 去官网下载也可以<br>   下载2019年的版本<br>或者:<br>    某度云加速下载看这里:<a target="_blank" rel="noopener" href="https://www.duckflew.cn/archives/%E4%B8%80%E4%BA%9B%E4%BC%98%E8%B4%A8%E7%BD%91%E7%AB%99">链接</a><br>   <img src="https://image.duckflew.cn/img/blog_inner_image20201101171345.png" style="zoom:50%;" /></p>
<p>   破解包我就放在这里了 可以直接下载</p>
<p>   破解包：<a target="_blank" rel="noopener" href="https://www.90pan.com/b2051501"> 点击下载文件 </a><br>   密码：zip6</p>
<p>   写的是idea激活 其实都是通用的<br>   我是在果核剥壳网站找的</p>
<p>   这个网站里面有很多东西 包括CWS经常提到的墨墨背单词也有 自行下载即可<br>   （其实我觉得这个软件也确实比百词斩好用，但是CWS是不是吹的有点过了？唉反正都快要四级考试 英语刚拉跨 早点准备好呀    软件下起来下起来）</p>
<p>   这里我建议你们注册一个账号  我觉得这个网站还是值得注册的</p>
<img src="https://image.duckflew.cn/img/blog_inner_image20201101171347.png" style="zoom:50%;" />

<p>   下载完了得到这个安装包</p>
<p><img src="https://image.duckflew.cn/img/blog_inner_image20201101171348.png"></p>
<p>解压随便了 把里面的lib目录下面的jar文件提取出来</p>
<p><img src="https://image.duckflew.cn/img/blog_inner_image20201101171351.png"></p>
<p>下面来安装Clion</p>
<img src="https://image.duckflew.cn/img/blog_inner_image20201101171352.png" style="zoom:50%;" />
<img src="http://img.duckflew.cn/imageQQ图片20200906174902.png" style="zoom:50%;" />
<img src="https://image.duckflew.cn/img/blog_inner_image20201101171356.png" style="zoom:50%;" />

<p>目录随便选 但是建议就改一下盘符其他的不动 不要用中文</p>
<img src="https://image.duckflew.cn/img/blog_inner_image20201101171400.png" style="zoom:50%;" />

<img src="https://image.duckflew.cn/img/blog_inner_image20201101171402.png" style="zoom:50%;" />

<img src="https://image.duckflew.cn/img/blog_inner_image20201101171406.png" style="zoom:50%;" />

<p>提示这个的时候 直接导入我给的配置文件把 这是链接</p>
<p>配置文件下载连接：</p>
<p><a target="_blank" rel="noopener" href="https://wws.lanzous.com/iulBmfu39gd">配置文件</a></p>
<p>下面是激活页面</p>
<img src="https://image.duckflew.cn/img/blog_inner_image20201101171408.png" style="zoom:50%;" />

<p>这里我们选择试用</p>
<img src="https://image.duckflew.cn/img/blog_inner_image20201101171409.png" style="zoom:50%;" />

<p>点击Exaluate</p>
<img src="https://image.duckflew.cn/img/blog_inner_image20201101171411.png" style="zoom:50%;" />

<p>进来了</p>
<p>然后用破解包激活</p>
<p>直接把刚才的jar包拖进去</p>
<p>会提示restart</p>
<p>重启编译器即可</p>
<img src="https://image.duckflew.cn/img/blog_inner_image20201101171413.png" style="zoom:50%;" />

<p>重启编译器之后可能会出现这个</p>
<p>选择为Clion安装</p>
<p>如果提示重启就再重启</p>
<img src="https://image.duckflew.cn/img/blog_inner_image20201101171415.png" style="zoom:50%;" />

<p>这里我们进去看一下   许可证期限</p>
<p>新建一个项目 随便建</p>
<p>进去就是这样的</p>
<p>找到help菜单</p>
<img src="https://image.duckflew.cn/img/blog_inner_image20201101171417.png" style="zoom:50%;" />

<p><img src="https://image.duckflew.cn/img/blog_inner_image20201101171419.png"></p>
<p>如果有这行字就是说明激活成功了 许可证到2089年 人没了编译器还在</p>
<h2 id="3．配置MINGW64"><a href="#3．配置MINGW64" class="headerlink" title="3．配置MINGW64"></a>3．配置MINGW64</h2><p>打开Clion 下面进入配置</p>
<p>选择file菜单</p>
<img src="https://image.duckflew.cn/img/blog_inner_image20201101171422.png" style="zoom:50%;" />
搜索chain
然后找到toolchain选项

<img src="https://image.duckflew.cn/img/blog_inner_image20201101171424.png" alt="0d9d76b0e7c7f7e0eeb3839505ab33a5" style="zoom:50%;" />
       选择MINGW default
       这里导入MINGW的安装位置       
       直接找到DEV的安装目录 选择MINGW即可
       没有dev的就直接选择你刚才解压的MINGW的目录
<img src="https://image.duckflew.cn/img/blog_inner_image20201101171426.png" alt="a4960f8b9c0e1f51b9e508f7642a0ad7" style="zoom:50%;" />
导入成功就是这样的,然后修改C++ Complier那一项,把bin后面那一段(如果bin后面没有了就加上)修改为我下面这样的,点击这三个点可以找到这个`x86_68-w64-mingw32-g++.exe`

<p><img src="https://image.duckflew.cn/img/blog_inner_image20201101171429.png" alt="image-20200907193642624"></p>
<p>无论mingw64的路径在哪 配置的时候基本上都这个 样的形式</p>
<p><img src="https://image.duckflew.cn/img/blog_inner_image20210101224824.png"></p>
<p>选择apply 然后OK</p>
<img src="https://image.duckflew.cn/img/blog_inner_image20201101171431.png" alt="477fae9d061bad80c01bbbde99b1dad1" style="zoom:50%;" />

<p>​    创建一个项目试试  注意   文件路径不要有中文,否则会报项目无法构建的错误<br><img src="https://image.duckflew.cn/img/blog_inner_image20201101171442.png" style="zoom:50%;" /><br>​      跑一下代码试试<br><img src="https://image.duckflew.cn/img/blog_inner_image20201101171439.png" style="zoom:50%;" /><br>​     完成！</p>
<p>注意  经常在clion的控制台会出现乱码  建议手动去运行</p>
<p><img src="https://image.duckflew.cn/img/blog_inner_image20201101171442.png" alt="image-20200907194013971"></p>
<p>这个生成的文件夹下的你的项目对应的文件  </p>
<p>是在是出现乱码了 或者以DEBUG的模式启动</p>
<p>再不行去网上搜索   一般是设置项目的编码为UTF-8</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://129duckflew.github.io/2021/03/21/Clion%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE/" data-id="ckmjbdb8u0000m4veeysm8p5d" data-title="Clion安装与配置" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-chrome扩展安装教程" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/03/21/chrome%E6%89%A9%E5%B1%95%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/" class="article-date">
  <time class="dt-published" datetime="2021-03-21T15:31:56.746Z" itemprop="datePublished">2021-03-21</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/03/21/chrome%E6%89%A9%E5%B1%95%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/">chrome扩展安装教程</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p> 由于被问过很多次 所以在这里出个chrome插件安装使用和油猴脚本的教程吧 </p>
<p>首先解释一下一个小问题  这个问题的来源来自WS同学 第一次安装chrome没有设置搜索引擎导致无法上网</p>
<p> 谷歌的搜索引擎在国内是被墙了的 所以安装完chrome之后第一件事情就是要安装一个助手使得你能够访问谷歌的服务<br> 当然了 如果你只是搜索一下东西不需要这么多插件 建议升级新版的Microsoft Edge 目前据说市场占有率<br>已经超过了火狐位居第二了</p>
<h1 id="所以WS你知道了吗？"><a href="#所以WS你知道了吗？" class="headerlink" title="所以WS你知道了吗？"></a>所以WS你知道了吗？</h1><h2 id="废话少说开始安装"><a href="#废话少说开始安装" class="headerlink" title="废话少说开始安装"></a>废话少说开始安装</h2><p> chrome安装是不让选定目录的所以不要明移动目录可能会出现很多BUG<br> chrome 离线安装包和访问助手链接<br> <a target="_blank" rel="noopener" href="https://www.90pan.com/b2107521">chrome安装包</a><br> <a target="_blank" rel="noopener" href="https://www.90pan.com/b2107523">谷歌访问助手</a><br> 下载完了安装chrome无脑下一步  不过估计也没几步安装完成就可以打开了</p>
<h2 id="点击右上角的三个点"><a href="#点击右上角的三个点" class="headerlink" title="点击右上角的三个点"></a>点击右上角的三个点</h2><p> <img src="https://image.duckflew.cn/img/blog_inner_image20201101171110.png"></p>
<h2 id="进入设置"><a href="#进入设置" class="headerlink" title="进入设置"></a>进入设置</h2><p>由于目前还无法访问谷歌扩展商店 只能用打包好的谷歌访问助手 把你们刚才下载的谷歌访问助手打开解压放到桌面就行</p>
<img src="https://image.duckflew.cn/img/blog_inner_image20201101171210.png" style="zoom:50%;" />

<p>解压完成得到这个文件夹<br><img src="http://img.duckflew.cn/image%E6%96%87%E4%BB%B6%E5%A4%B9.png" style="zoom:50%;" /></p>
<p>回到chrome浏览器在页面的右上角打开开发者模式<br><img src="http://img.duckflew.cn/image%E5%BC%80%E5%8F%91%E8%80%85%E6%A8%A1%E5%BC%8F.png"><br>把刚才解压的文件夹整个拖入页面<br><img src="http://img.duckflew.cn/image%E6%8B%96%E5%85%A5.png" style="zoom:50%;" /><br>这样就安装完成了助手了把助手启用<br> 接下来回到主页面把助手固定上来<br><img src="http://img.duckflew.cn/image%E5%9B%BA%E5%AE%9A.png" style="zoom:50%;" /><br>连接一下<br><img src="http://img.duckflew.cn/image%E8%BF%9E%E6%8E%A5.png" style="zoom:50%;" /></p>
<p>补充一下 但凡是需要访问谷歌的服务你要么使用助手要么KX上网<br>这种免费的助手速度就不是很快了 所以日常使用还是切换回百度搜索引擎即可 其实我个人建议必应<br>接下来安装脚本 就是你们问的最多的刷网课的<br>使用脚本需要一个管理器  就是油猴了 全称是tampermonkey 它是一个插件需要在扩展商店安装<br><img src="http://img.duckflew.cn/image%E6%B2%B9%E7%8C%B4.png" style="zoom:50%;" /> </p>
<p>第一个就是的<br><img src="http://img.duckflew.cn/image%E6%B2%B9%E7%8C%B4%E8%B0%B7%E6%AD%8C.png" style="zoom:50%;" /><br>有了脚本管理器 接下来只需要脚本了<br>搜索greasyfork<br><img src="http://img.duckflew.cn/image%E6%B2%B9%E5%8F%89.png" style="zoom:50%;" /></p>
<p>在这里搜索你需要的脚本</p>
<img src="http://img.duckflew.cn/image%E6%B2%B9%E5%8F%89%E4%B8%BB%E9%A1%B5.png" style="zoom:50%;" />
贴个我个人在用的    
<img src="http://img.duckflew.cn/imageB%E7%AB%99%E8%BF%9B%E5%8C%96.png" style="zoom:50%;" />

<h2 id="点击进去直接选择安装此脚本"><a href="#点击进去直接选择安装此脚本" class="headerlink" title="点击进去直接选择安装此脚本"></a>点击进去直接选择安装此脚本</h2><p>至于刷网课的脚本主流平台一般都有 不过经过了一轮跑路事件  题库质量下降 只能刷刷水课了 主流平台都有自己搜索把<br>还有很多功能性的脚本 比如淘宝比价啊  自动获取最近一段时间的最低价 和最高价和优惠卷信息  又比如某DU网盘直连获取 配合IDM下载器 可以实现加速  关于IDM下载器没啥人问过我就懒得说了,再比如说去某度的广告的脚本 等等 另外其实脚本网站还有两个但是用的稍微少一点网址可以在油猴里面找到</p>
<h2 id="chrome安装插件也是差不多的操作"><a href="#chrome安装插件也是差不多的操作" class="headerlink" title="chrome安装插件也是差不多的操作"></a>chrome安装插件也是差不多的操作</h2><p>进入扩展商店<br>随便搜索个插件<br>比如<br><img src="http://img.duckflew.cn/image%E4%B9%A6%E7%AD%BE%E4%BE%A7%E8%BE%B9%E6%A0%8F.png" style="zoom:50%;" /><br>直接点击安装就好了<br>这就是安装完的效果了<br><img src="http://img.duckflew.cn/image%E5%AE%89%E8%A3%85%E5%AE%8C%E7%9A%84%E6%95%88%E6%9E%9C.png" style="zoom:50%;" /><br>功能强大的插件还有很多 总有适合你的 根据自己的需求去搜索即可</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://129duckflew.github.io/2021/03/21/chrome%E6%89%A9%E5%B1%95%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/" data-id="ckmjbdb920004m4vedilj4pg2" data-title="chrome扩展安装教程" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-hello-world" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/03/21/hello-world/" class="article-date">
  <time class="dt-published" datetime="2021-03-21T13:17:39.654Z" itemprop="datePublished">2021-03-21</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <hr>
<h2 id="hello-world"><a href="#hello-world" class="headerlink" title="hello-world"></a>hello-world</h2><hr>
<h2 id="title-Hello-World"><a href="#title-Hello-World" class="headerlink" title="title: Hello World"></a>title: Hello World</h2><p>Welcome to <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a target="_blank" rel="noopener" href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a target="_blank" rel="noopener" href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a target="_blank" rel="noopener" href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://129duckflew.github.io/2021/03/21/hello-world/" data-id="ckmjc2r510000vovefpphg0v4" data-title="" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/">&laquo; Prev</a><a class="page-number" href="/">1</a><span class="page-number current">2</span>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/03/">March 2021</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2021/03/21/%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F/">希尔排序</a>
          </li>
        
          <li>
            <a href="/2021/03/21/%E5%87%A0%E4%B8%AA%E5%A5%BD%E7%94%A8%E7%9A%84%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7/">几个好用的命令行工具</a>
          </li>
        
          <li>
            <a href="/2021/03/21/%E5%87%A0%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/">几大排序算法总结</a>
          </li>
        
          <li>
            <a href="/2021/03/21/%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91%E7%9A%84%E5%BB%BA%E7%AB%8B%E4%BB%A5%E5%8F%8A%E6%B1%82WPL%20%E4%BB%A5%E5%8F%8A%E5%93%88%E5%A4%AB%E6%9B%BC%E7%BC%96%E7%A0%81/">哈夫曼树的建立以及求WPL 以及哈夫曼编码</a>
          </li>
        
          <li>
            <a href="/2021/03/21/%E5%B9%BF%E4%B9%89%E8%A1%A8/">广义表</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2021 duckflew<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>